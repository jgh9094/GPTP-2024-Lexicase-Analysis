[["index.html", "Supplemental Material for ‘Hidden Lexicase Selection Parameters: Varying Population Size and Test Case Redundancy with Diagnostic Metrics’ Chapter 1 Introduction 1.1 About our supplemental material 1.2 Contributing authors", " Supplemental Material for ‘Hidden Lexicase Selection Parameters: Varying Population Size and Test Case Redundancy with Diagnostic Metrics’ Jose Guadalupe Hernandez, Anil Kumar Saini, Jason H. Moore 2024-05-06 Chapter 1 Introduction This is not intended as a stand-alone document, but as a companion to our manuscript. 1.1 About our supplemental material As you may have noticed (unless you’re reading a pdf version of this), our supplemental material is hosted using GitHub pages. We compiled our data analyses and supplemental documentation into this nifty web-accessible book using bookdown. The code used for this supplemental material can be found in this GitHub repository. Our supplemental material includes the following: Exploitation rate results (Section 2) Contradictory rates results w/ 100 standard test cases (Section 3) Contradictory rates results w/ 50 redundant test cases (Section 4) Contradictory rates results w/ 100 redundant test cases (Section 5) Contradictory rates results w/ 200 redundant test cases (Section 6) Contradictory rates results w/ 300 redundant test cases (Section 7) 1.2 Contributing authors Jose Guadalupe Hernandez Anil Kumar Saini Jason H. Moore "],["exploitation-rate-results.html", "Chapter 2 Exploitation rate results 2.1 Analysis setup 2.2 Performance over time 2.3 Best performance evolved 2.4 Evaluation satisfactory solution if found", " Chapter 2 Exploitation rate results Here we report the performance and evaluation a satisfactory solution was found on the exploitation rate diagnostic. 50 replicates were conducted for each population size explored. Performance is defined at the average trait performance, where we collect the best performing solution in each generation over time and the best performing solution evolved. A satisfactory solution is defined as a solution that has a phenotype with all traits greater than or equal to 99.0. 2.1 Analysis setup library(ggplot2) library(cowplot) library(dplyr) library(PupillometryR) # over time data over_time &lt;- read.csv(&quot;../Paper_Data/Exploitation/ot.csv&quot;, header = TRUE, stringsAsFactors = FALSE) over_time$pop_size &lt;- factor(over_time$pop_size, levels = NAMES) # best performance data best &lt;- read.csv(&#39;../Paper_Data/Exploitation/best.csv&#39;, header = TRUE, stringsAsFactors = FALSE) best$pop_size &lt;- factor(best$pop_size, levels = NAMES) # get the data ssf &lt;- read.csv(&#39;../Paper_Data/Exploitation/ssf.csv&#39;, header = TRUE, stringsAsFactors = FALSE) ssf$pop_size &lt;- factor(ssf$pop_size, levels = NAMES) ssf &lt;- filter(ssf, evaluation &lt;= 1.5*10^9) 2.2 Performance over time Performance of the best solution in the population at each generation over time. # aggregate lines = over_time %&gt;% group_by(pop_size, eval) %&gt;% dplyr::summarise( min = min(performance), mean = mean(performance), max = max(performance) ) lines$pop_size &lt;- factor(lines$pop_size, levels = NAMES) ggplot(lines, aes(x=eval, y=mean, group = pop_size, fill = pop_size, color = pop_size, shape = pop_size)) + geom_ribbon(aes(ymin = min, ymax = max), alpha = 0.1) + geom_line(linewidth = 0.5) + geom_point(data = filter(lines, eval %% 100000000 == 0 &amp; eval != 0), size = 1.0, stroke = 2.0, alpha = 1.0) + scale_y_continuous( name=&quot;Average trait score&quot;, limits=c(0, 100), breaks=seq(0,100, 25), labels=c(&quot;0&quot;, &quot;25&quot;, &quot;50&quot;, &quot;75&quot;, &quot;100&quot;) ) + scale_x_continuous( name=&quot;Evaluation&quot;, labels = c(&#39;0.0e+0&#39;, &#39;5.0e+8&#39;,&#39;1.0e+9&#39;,&#39;1.5e+9&#39;), limits = c(0,1520000000) ) + scale_shape_manual(values=SHAPE)+ scale_colour_manual(values = cb_palette) + scale_fill_manual(values = cb_palette) + ggtitle(&#39;Performance over time&#39;)+ p_theme + guides( shape=guide_legend(nrow=2, title.position = &quot;left&quot;, title = &#39;Population\\nSize&#39;), color=guide_legend(nrow=2, title.position = &quot;left&quot;, title = &#39;Population\\nSize&#39;), fill=guide_legend(nrow=2, title.position = &quot;left&quot;, title = &#39;Population\\nSize&#39;) ) 2.3 Best performance evolved Performance of the best solution found throughout the entire evolutionary run. ggplot(best, aes(x = pop_size, y = performance, color = pop_size, fill = pop_size, shape = pop_size)) + geom_flat_violin(position = position_nudge(x = .1, y = 0), scale = &#39;width&#39;, alpha = 0.2, width = 1.5) + geom_boxplot(color = &#39;black&#39;, width = .07, outlier.shape = NA, alpha = 0.0, size = 1.0, position = position_nudge(x = .16, y = 0)) + geom_point(position = position_jitter(width = 0.02, height = 0.0001), size = 1.5, alpha = 1.0) + scale_y_continuous( name=&quot;Average trait score&quot;, limits=c(0, 100), breaks=seq(0,100, 25), labels=c(&quot;0&quot;, &quot;25&quot;, &quot;50&quot;, &quot;75&quot;, &quot;100&quot;) ) + scale_x_discrete( name=&quot;Population Size&quot; )+ scale_shape_manual(values=SHAPE)+ scale_colour_manual(values = cb_palette, ) + scale_fill_manual(values = cb_palette) + ggtitle(&#39;Best performance throughout&#39;)+ p_theme+ coord_flip() + guides( shape=guide_legend(nrow=2, title.position = &quot;left&quot;, title = &#39;Population\\nSize&#39;), color=guide_legend(nrow=2, title.position = &quot;left&quot;, title = &#39;Population\\nSize&#39;), fill=guide_legend(nrow=2, title.position = &quot;left&quot;, title = &#39;Population\\nSize&#39;) ) 2.3.1 Summary statistics best %&gt;% group_by(pop_size) %&gt;% dplyr::summarise( count = n(), na_cnt = sum(is.na(performance)), min = min(performance, na.rm = TRUE), median = median(performance, na.rm = TRUE), mean = mean(performance, na.rm = TRUE), max = max(performance, na.rm = TRUE), IQR = IQR(performance, na.rm = TRUE) ) ## # A tibble: 5 × 8 ## pop_size count na_cnt min median mean max IQR ## &lt;fct&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 50 50 0 99.9 99.9 99.9 99.9 0.0149 ## 2 100 50 0 99.9 99.9 99.9 99.9 0.0166 ## 3 500 50 0 99.9 99.9 99.9 99.9 0.0235 ## 4 1000 50 0 79.0 79.9 80.0 81.8 0.779 ## 5 5000 50 0 19.0 19.4 19.4 20.0 0.299 2.3.2 Kruskal-Wallis test kruskal.test(performance ~ pop_size, data = best) ## ## Kruskal-Wallis rank sum test ## ## data: performance by pop_size ## Kruskal-Wallis chi-squared = 198.29, df = 4, ## p-value &lt; 2.2e-16 2.3.3 Pairwise wilcoxon test pairwise.wilcox.test(x = best$performance, g = best$pop_size, p.adjust.method = &quot;bonferroni&quot;, paired = FALSE, conf.int = FALSE, alternative = &#39;l&#39;) ## ## Pairwise comparisons using Wilcoxon rank sum test with continuity correction ## ## data: best$performance and best$pop_size ## ## 50 100 500 1000 ## 100 1.00000 - - - ## 500 0.00078 0.00059 - - ## 1000 &lt; 2e-16 &lt; 2e-16 &lt; 2e-16 - ## 5000 &lt; 2e-16 &lt; 2e-16 &lt; 2e-16 &lt; 2e-16 ## ## P value adjustment method: bonferroni 2.4 Evaluation satisfactory solution if found Evaluation a satisfactory solution is found for each population size. ggplot(ssf, aes(x = pop_size, y = evaluation, color = pop_size, fill = pop_size, shape = pop_size)) + geom_flat_violin(position = position_nudge(x = 0.12, y = 0), scale = &#39;width&#39;, alpha = 0.2, width = 1.5) + geom_boxplot(color = &#39;black&#39;, width = .08, outlier.shape = NA, alpha = 0.0, size = 0.8, position = position_nudge(x = .19, y = 0)) + geom_point(position = position_jitter(width = 0.03, height = 0.000001), size = 1.5, alpha = 1.0) + scale_y_continuous( name = &#39;Evaluation&#39;, breaks = c(100000000,500000000,1000000000,1500000000), labels = c(&#39;1.0e+8&#39;, &#39;5.0e+8&#39;,&#39;1.0e+9&#39;,&#39;1.5e+9&#39;), limits = c(100000000,1500000000) ) + scale_x_discrete( name=&quot;Population Size&quot;, )+ scale_shape_manual(values=SHAPE, )+ scale_colour_manual(values = cb_palette, ) + scale_fill_manual(values = cb_palette) + ggtitle(bquote(&#39;Evaluation Satisfactory Solution Found&#39;))+ p_theme + coord_flip() + guides( shape=guide_legend(nrow=2, title.position = &quot;left&quot;, title = &#39;Population\\nSize&#39;), color=guide_legend(nrow=2, title.position = &quot;left&quot;, title = &#39;Population\\nSize&#39;), fill=guide_legend(nrow=2, title.position = &quot;left&quot;, title = &#39;Population\\nSize&#39;) ) 2.4.1 Summary statistics ssf %&gt;% group_by(pop_size) %&gt;% dplyr::summarise( count = n(), na_cnt = sum(is.na(evaluation)), min = min(evaluation, na.rm = TRUE), median = median(evaluation, na.rm = TRUE), mean = mean(evaluation, na.rm = TRUE), max = max(evaluation, na.rm = TRUE), IQR = IQR(evaluation, na.rm = TRUE) ) ## # A tibble: 3 × 8 ## pop_size count na_cnt min median mean max IQR ## &lt;fct&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 50 50 0 1.35e8 2.13e8 2.52e8 8.04e8 1.32e8 ## 2 100 50 0 2.55e8 3.38e8 3.65e8 8.83e8 8.37e7 ## 3 500 50 0 1.16e9 1.27e9 1.28e9 1.44e9 9.10e7 2.4.2 Kruskal-Wallis test kruskal.test(evaluation ~ pop_size, data = ssf) ## ## Kruskal-Wallis rank sum test ## ## data: evaluation by pop_size ## Kruskal-Wallis chi-squared = 113.38, df = 2, ## p-value &lt; 2.2e-16 2.4.3 Pairwise wilcoxon test pairwise.wilcox.test(x = ssf$evaluation, g = ssf$pop_size, p.adjust.method = &quot;bonferroni&quot;, paired = FALSE, conf.int = FALSE, alternative = &#39;g&#39;) ## ## Pairwise comparisons using Wilcoxon rank sum test with continuity correction ## ## data: ssf$evaluation and ssf$pop_size ## ## 50 100 ## 100 3.1e-08 - ## 500 &lt; 2e-16 &lt; 2e-16 ## ## P value adjustment method: bonferroni "],["contradictory-objectives-100-results.html", "Chapter 3 Contradictory objectives 100 results 3.1 Analysis setup 3.2 Activation gene coverage 3.3 Satisfactory trait coverage", " Chapter 3 Contradictory objectives 100 results Here we report the activation gene coverage and satisfactory trait coverage was found on the contradictory objectives diagnostic. 50 replicates were conducted for each population size explored. Activation gene coverage is calculated by finding all the unique activation genes found within a given population. Satisfactory trait coverage is calculated by finding all the unique satisfactory traits found within a given population. 3.1 Analysis setup library(ggplot2) library(cowplot) library(dplyr) library(PupillometryR) # over time data over_time &lt;- read.csv(&quot;../Paper_Data/Contradictory-100/ot.csv&quot;, header = TRUE, stringsAsFactors = FALSE) over_time$pop_size &lt;- factor(over_time$pop_size, levels = NAMES) # best performance data best &lt;- read.csv(&#39;../Paper_Data/Contradictory-100/best.csv&#39;, header = TRUE, stringsAsFactors = FALSE) best$pop_size &lt;- factor(best$pop_size, levels = NAMES) 3.2 Activation gene coverage 3.2.1 Coverage over time Performance of the best solution in the population at each generation over time. # aggregate lines = over_time %&gt;% group_by(pop_size, eval) %&gt;% dplyr::summarise( min = min(activation_coverage), mean = mean(activation_coverage), max = max(activation_coverage) ) lines$pop_size &lt;- factor(lines$pop_size, levels = NAMES) ggplot(lines, aes(x=eval, y=mean, group = pop_size, fill = pop_size, color = pop_size, shape = pop_size)) + geom_ribbon(aes(ymin = min, ymax = max), alpha = 0.1) + geom_line(linewidth = 0.5) + geom_point(data = filter(lines, eval %% 100000000 == 0 &amp; eval != 0), size = 1.0, stroke = 2.0, alpha = 1.0) + scale_y_continuous( name=&quot;Coverage&quot;, limits=c(0, 100), breaks=seq(0,100, 25), labels=c(&quot;0&quot;, &quot;25&quot;, &quot;50&quot;, &quot;75&quot;, &quot;100&quot;) ) + scale_x_continuous( name=&quot;Evaluation&quot;, labels = c(&#39;0.0e+0&#39;, &#39;5.0e+8&#39;,&#39;1.0e+9&#39;,&#39;1.5e+9&#39;), limits = c(0,1520000000) ) + scale_shape_manual(values=SHAPE)+ scale_colour_manual(values = cb_palette) + scale_fill_manual(values = cb_palette) + ggtitle(&#39;Activation gene over time&#39;)+ p_theme + guides( shape=guide_legend(nrow=2, title.position = &quot;left&quot;, title = &#39;Population\\nSize&#39;), color=guide_legend(nrow=2, title.position = &quot;left&quot;, title = &#39;Population\\nSize&#39;), fill=guide_legend(nrow=2, title.position = &quot;left&quot;, title = &#39;Population\\nSize&#39;) ) 3.3 Satisfactory trait coverage 3.3.1 Coverage over time Satisfactory trait coverage over time. # aggregate lines = over_time %&gt;% group_by(pop_size, eval) %&gt;% dplyr::summarise( min = min(satisfactory_coverage), mean = mean(satisfactory_coverage), max = max(satisfactory_coverage) ) lines$pop_size &lt;- factor(lines$pop_size, levels = NAMES) ggplot(lines, aes(x=eval, y=mean, group = pop_size, fill = pop_size, color = pop_size, shape = pop_size)) + geom_ribbon(aes(ymin = min, ymax = max), alpha = 0.1) + geom_line(linewidth = 0.5) + geom_point(data = filter(lines, eval %% 100000000 == 0 &amp; eval != 0), size = 1.0, stroke = 2.0, alpha = 1.0) + scale_y_continuous( name=&quot;Coverage&quot;, limits=c(0, 100), breaks=seq(0,100, 25), labels=c(&quot;0&quot;, &quot;25&quot;, &quot;50&quot;, &quot;75&quot;, &quot;100&quot;) ) + scale_x_continuous( name=&quot;Evaluation&quot;, labels = c(&#39;0.0e+0&#39;, &#39;5.0e+8&#39;,&#39;1.0e+9&#39;,&#39;1.5e+9&#39;), limits = c(0,1520000000) ) + scale_shape_manual(values=SHAPE)+ scale_colour_manual(values = cb_palette) + scale_fill_manual(values = cb_palette) + ggtitle(&#39;Activation gene over time&#39;)+ p_theme + guides( shape=guide_legend(nrow=2, title.position = &quot;left&quot;, title = &#39;Population\\nSize&#39;), color=guide_legend(nrow=2, title.position = &quot;left&quot;, title = &#39;Population\\nSize&#39;), fill=guide_legend(nrow=2, title.position = &quot;left&quot;, title = &#39;Population\\nSize&#39;) ) 3.3.2 Best satisfactory trait coverage found throughout run Satisfactory trait coverage of the best population found throughout an evolutionary run. ggplot(best, aes(x = pop_size, y = coverage, color = pop_size, fill = pop_size, shape = pop_size)) + geom_flat_violin(position = position_nudge(x = .1, y = 0), scale = &#39;width&#39;, alpha = 0.2, width = 1.5) + geom_boxplot(color = &#39;black&#39;, width = .07, outlier.shape = NA, alpha = 0.0, size = 1.0, position = position_nudge(x = .16, y = 0)) + geom_point(position = position_jitter(width = 0.02, height = 0.0001), size = 1.5, alpha = 1.0) + scale_y_continuous( name=&quot;Coverage&quot;, limits=c(0, 100), breaks=seq(0,100, 25), labels=c(&quot;0&quot;, &quot;25&quot;, &quot;50&quot;, &quot;75&quot;, &quot;100&quot;), ) + scale_x_discrete( name=&quot;Population Size&quot; )+ scale_shape_manual(values=SHAPE)+ scale_colour_manual(values = cb_palette, ) + scale_fill_manual(values = cb_palette) + ggtitle(&#39; Best satisfactory coverage&#39;)+ p_theme + coord_flip() + guides( shape=guide_legend(nrow=2, title.position = &quot;left&quot;, title = &#39;Population\\nSize&#39;), color=guide_legend(nrow=2, title.position = &quot;left&quot;, title = &#39;Population\\nSize&#39;), fill=guide_legend(nrow=2, title.position = &quot;left&quot;, title = &#39;Population\\nSize&#39;) ) ## Warning: Removed 29 rows containing missing values ## (`geom_point()`). 3.3.2.1 Summary statistics best %&gt;% group_by(pop_size) %&gt;% dplyr::summarise( count = n(), na_cnt = sum(is.na(coverage)), min = min(coverage, na.rm = TRUE), median = median(coverage, na.rm = TRUE), mean = mean(coverage, na.rm = TRUE), max = max(coverage, na.rm = TRUE), IQR = IQR(coverage, na.rm = TRUE) ) ## # A tibble: 5 × 8 ## pop_size count na_cnt min median mean max IQR ## &lt;fct&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 50 50 0 7 9 9.36 11 1 ## 2 100 50 0 9 10 10.1 13 1 ## 3 500 50 0 44 47 47.0 51 2 ## 4 1000 50 0 86 90 90.0 94 2 ## 5 5000 50 0 100 100 100 100 0 3.3.2.2 Kruskal-Wallis test kruskal.test(coverage ~ pop_size, data = best) ## ## Kruskal-Wallis rank sum test ## ## data: coverage by pop_size ## Kruskal-Wallis chi-squared = 232.33, df = 4, ## p-value &lt; 2.2e-16 3.3.2.3 Pairwise wilcoxon test pairwise.wilcox.test(x = best$coverage, g = best$pop_size, p.adjust.method = &quot;bonferroni&quot;, paired = FALSE, conf.int = FALSE, alternative = &#39;g&#39;) ## ## Pairwise comparisons using Wilcoxon rank sum test with continuity correction ## ## data: best$coverage and best$pop_size ## ## 50 100 500 1000 ## 100 0.0019 - - - ## 500 &lt;2e-16 &lt;2e-16 - - ## 1000 &lt;2e-16 &lt;2e-16 &lt;2e-16 - ## 5000 &lt;2e-16 &lt;2e-16 &lt;2e-16 &lt;2e-16 ## ## P value adjustment method: bonferroni "],["contradictory-objectives-150-results.html", "Chapter 4 Contradictory objectives 150 results 4.1 Analysis setup 4.2 Activation gene coverage 4.3 Satisfactory trait coverage", " Chapter 4 Contradictory objectives 150 results Here we report the activation gene coverage and satisfactory trait coverage was found on the contradictory objectives diagnostic. 50 replicates were conducted for each population size explored. Activation gene coverage is calculated by finding all the unique activation genes found within a given population. Satisfactory trait coverage is calculated by finding all the unique satisfactory traits found within a given population. 4.1 Analysis setup library(ggplot2) library(cowplot) library(dplyr) library(PupillometryR) # over time data over_time &lt;- read.csv(&quot;../Paper_Data/Contradictory-150/ot.csv&quot;, header = TRUE, stringsAsFactors = FALSE) over_time$pop_size &lt;- factor(over_time$pop_size, levels = NAMES) # best performance data best &lt;- read.csv(&#39;../Paper_Data/Contradictory-150/best.csv&#39;, header = TRUE, stringsAsFactors = FALSE) best$pop_size &lt;- factor(best$pop_size, levels = NAMES) 4.2 Activation gene coverage 4.2.1 Coverage over time Performance of the best solution in the population at each generation over time. # aggregate lines = over_time %&gt;% group_by(pop_size, eval) %&gt;% dplyr::summarise( min = min(activation_coverage), mean = mean(activation_coverage), max = max(activation_coverage) ) lines$pop_size &lt;- factor(lines$pop_size, levels = NAMES) ggplot(lines, aes(x=eval, y=mean, group = pop_size, fill = pop_size, color = pop_size, shape = pop_size)) + geom_ribbon(aes(ymin = min, ymax = max), alpha = 0.1) + geom_line(linewidth = 0.5) + geom_point(data = filter(lines, eval %% 100000000 == 0 &amp; eval != 0), size = 1.0, stroke = 2.0, alpha = 1.0) + scale_y_continuous( name=&quot;Coverage&quot;, limits=c(0, 100), breaks=seq(0,100, 25), labels=c(&quot;0&quot;, &quot;25&quot;, &quot;50&quot;, &quot;75&quot;, &quot;100&quot;) ) + scale_x_continuous( name=&quot;Evaluation&quot;, labels = c(&#39;0.0e+0&#39;, &#39;5.0e+8&#39;,&#39;1.0e+9&#39;,&#39;1.5e+9&#39;), limits = c(0,1520000000) ) + scale_shape_manual(values=SHAPE)+ scale_colour_manual(values = cb_palette) + scale_fill_manual(values = cb_palette) + ggtitle(&#39;Activation gene over time&#39;)+ p_theme + guides( shape=guide_legend(nrow=2, title.position = &quot;left&quot;, title = &#39;Population\\nSize&#39;), color=guide_legend(nrow=2, title.position = &quot;left&quot;, title = &#39;Population\\nSize&#39;), fill=guide_legend(nrow=2, title.position = &quot;left&quot;, title = &#39;Population\\nSize&#39;) ) 4.3 Satisfactory trait coverage 4.3.1 Coverage over time Satisfactory trait coverage over time. # aggregate lines = over_time %&gt;% group_by(pop_size, eval) %&gt;% dplyr::summarise( min = min(satisfactory_coverage), mean = mean(satisfactory_coverage), max = max(satisfactory_coverage) ) lines$pop_size &lt;- factor(lines$pop_size, levels = NAMES) ggplot(lines, aes(x=eval, y=mean, group = pop_size, fill = pop_size, color = pop_size, shape = pop_size)) + geom_ribbon(aes(ymin = min, ymax = max), alpha = 0.1) + geom_line(linewidth = 0.5) + geom_point(data = filter(lines, eval %% 100000000 == 0 &amp; eval != 0), size = 1.0, stroke = 2.0, alpha = 1.0) + scale_y_continuous( name=&quot;Coverage&quot;, limits=c(0, 100), breaks=seq(0,100, 25), labels=c(&quot;0&quot;, &quot;25&quot;, &quot;50&quot;, &quot;75&quot;, &quot;100&quot;) ) + scale_x_continuous( name=&quot;Evaluation&quot;, labels = c(&#39;0.0e+0&#39;, &#39;5.0e+8&#39;,&#39;1.0e+9&#39;,&#39;1.5e+9&#39;), limits = c(0,1520000000) ) + scale_shape_manual(values=SHAPE)+ scale_colour_manual(values = cb_palette) + scale_fill_manual(values = cb_palette) + ggtitle(&#39;Satisfactory trait coverage over time&#39;)+ p_theme + guides( shape=guide_legend(nrow=2, title.position = &quot;left&quot;, title = &#39;Population\\nSize&#39;), color=guide_legend(nrow=2, title.position = &quot;left&quot;, title = &#39;Population\\nSize&#39;), fill=guide_legend(nrow=2, title.position = &quot;left&quot;, title = &#39;Population\\nSize&#39;) ) 4.3.2 Best satisfactory trait coverage found throughout run Satisfactory trait coverage of the best population found throughout an evolutionary run. ggplot(best, aes(x = pop_size, y = coverage, color = pop_size, fill = pop_size, shape = pop_size)) + geom_flat_violin(position = position_nudge(x = .1, y = 0), scale = &#39;width&#39;, alpha = 0.2, width = 1.5) + geom_boxplot(color = &#39;black&#39;, width = .07, outlier.shape = NA, alpha = 0.0, size = 1.0, position = position_nudge(x = .16, y = 0)) + geom_point(position = position_jitter(width = 0.02, height = 0.0001), size = 1.5, alpha = 1.0) + scale_y_continuous( name=&quot;Coverage&quot;, limits=c(0, 100), breaks=seq(0,100, 25), labels=c(&quot;0&quot;, &quot;25&quot;, &quot;50&quot;, &quot;75&quot;, &quot;100&quot;), ) + scale_x_discrete( name=&quot;Population Size&quot; )+ scale_shape_manual(values=SHAPE)+ scale_colour_manual(values = cb_palette, ) + scale_fill_manual(values = cb_palette) + ggtitle(&#39; Best satisfactory coverage&#39;)+ p_theme + coord_flip() + guides( shape=guide_legend(nrow=2, title.position = &quot;left&quot;, title = &#39;Population\\nSize&#39;), color=guide_legend(nrow=2, title.position = &quot;left&quot;, title = &#39;Population\\nSize&#39;), fill=guide_legend(nrow=2, title.position = &quot;left&quot;, title = &#39;Population\\nSize&#39;) ) ## Warning: Removed 21 rows containing missing values ## (`geom_point()`). 4.3.2.1 Summary statistics best %&gt;% group_by(pop_size) %&gt;% dplyr::summarise( count = n(), na_cnt = sum(is.na(coverage)), min = min(coverage, na.rm = TRUE), median = median(coverage, na.rm = TRUE), mean = mean(coverage, na.rm = TRUE), max = max(coverage, na.rm = TRUE), IQR = IQR(coverage, na.rm = TRUE) ) ## # A tibble: 5 × 8 ## pop_size count na_cnt min median mean max IQR ## &lt;fct&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 50 50 0 4 6 5.86 9 2 ## 2 100 50 0 6 8 7.88 10 1 ## 3 500 50 0 30 38 37.8 42 3 ## 4 1000 50 0 54 59 58.4 62 3 ## 5 5000 50 0 100 100 100 100 0 4.3.2.2 Kruskal-Wallis test kruskal.test(coverage ~ pop_size, data = best) ## ## Kruskal-Wallis rank sum test ## ## data: coverage by pop_size ## Kruskal-Wallis chi-squared = 237.37, df = 4, ## p-value &lt; 2.2e-16 4.3.2.3 Pairwise wilcoxon test pairwise.wilcox.test(x = best$coverage, g = best$pop_size, p.adjust.method = &quot;bonferroni&quot;, paired = FALSE, conf.int = FALSE, alternative = &#39;g&#39;) ## ## Pairwise comparisons using Wilcoxon rank sum test with continuity correction ## ## data: best$coverage and best$pop_size ## ## 50 100 500 1000 ## 100 1.2e-11 - - - ## 500 &lt; 2e-16 &lt; 2e-16 - - ## 1000 &lt; 2e-16 &lt; 2e-16 &lt; 2e-16 - ## 5000 &lt; 2e-16 &lt; 2e-16 &lt; 2e-16 &lt; 2e-16 ## ## P value adjustment method: bonferroni "],["contradictory-objectives-200-results.html", "Chapter 5 Contradictory objectives 200 results 5.1 Analysis setup 5.2 Activation gene coverage 5.3 Satisfactory trait coverage", " Chapter 5 Contradictory objectives 200 results Here we report the activation gene coverage and satisfactory trait coverage was found on the contradictory objectives diagnostic. 50 replicates were conducted for each population size explored. Activation gene coverage is calculated by finding all the unique activation genes found within a given population. Satisfactory trait coverage is calculated by finding all the unique satisfactory traits found within a given population. 5.1 Analysis setup library(ggplot2) library(cowplot) library(dplyr) library(PupillometryR) # over time data over_time &lt;- read.csv(&quot;../Paper_Data/Contradictory-200/ot.csv&quot;, header = TRUE, stringsAsFactors = FALSE) over_time$pop_size &lt;- factor(over_time$pop_size, levels = NAMES) # best performance data best &lt;- read.csv(&#39;../Paper_Data/Contradictory-200/best.csv&#39;, header = TRUE, stringsAsFactors = FALSE) best$pop_size &lt;- factor(best$pop_size, levels = NAMES) 5.2 Activation gene coverage 5.2.1 Coverage over time Performance of the best solution in the population at each generation over time. # aggregate lines = over_time %&gt;% group_by(pop_size, eval) %&gt;% dplyr::summarise( min = min(activation_coverage), mean = mean(activation_coverage), max = max(activation_coverage) ) lines$pop_size &lt;- factor(lines$pop_size, levels = NAMES) ggplot(lines, aes(x=eval, y=mean, group = pop_size, fill = pop_size, color = pop_size, shape = pop_size)) + geom_ribbon(aes(ymin = min, ymax = max), alpha = 0.1) + geom_line(linewidth = 0.5) + geom_point(data = filter(lines, eval %% 100000000 == 0 &amp; eval != 0), size = 1.0, stroke = 2.0, alpha = 1.0) + scale_y_continuous( name=&quot;Coverage&quot;, limits=c(0, 100), breaks=seq(0,100, 25), labels=c(&quot;0&quot;, &quot;25&quot;, &quot;50&quot;, &quot;75&quot;, &quot;100&quot;) ) + scale_x_continuous( name=&quot;Evaluation&quot;, labels = c(&#39;0.0e+0&#39;, &#39;5.0e+8&#39;,&#39;1.0e+9&#39;,&#39;1.5e+9&#39;), limits = c(0,1520000000) ) + scale_shape_manual(values=SHAPE)+ scale_colour_manual(values = cb_palette) + scale_fill_manual(values = cb_palette) + ggtitle(&#39;Activation gene over time&#39;)+ p_theme + guides( shape=guide_legend(nrow=2, title.position = &quot;left&quot;, title = &#39;Population\\nSize&#39;), color=guide_legend(nrow=2, title.position = &quot;left&quot;, title = &#39;Population\\nSize&#39;), fill=guide_legend(nrow=2, title.position = &quot;left&quot;, title = &#39;Population\\nSize&#39;) ) 5.3 Satisfactory trait coverage 5.3.1 Coverage over time Satisfactory trait coverage over time. # aggregate lines = over_time %&gt;% group_by(pop_size, eval) %&gt;% dplyr::summarise( min = min(satisfactory_coverage), mean = mean(satisfactory_coverage), max = max(satisfactory_coverage) ) lines$pop_size &lt;- factor(lines$pop_size, levels = NAMES) ggplot(lines, aes(x=eval, y=mean, group = pop_size, fill = pop_size, color = pop_size, shape = pop_size)) + geom_ribbon(aes(ymin = min, ymax = max), alpha = 0.1) + geom_line(linewidth = 0.5) + geom_point(data = filter(lines, eval %% 100000000 == 0 &amp; eval != 0), size = 1.0, stroke = 2.0, alpha = 1.0) + scale_y_continuous( name=&quot;Coverage&quot;, limits=c(0, 100), breaks=seq(0,100, 25), labels=c(&quot;0&quot;, &quot;25&quot;, &quot;50&quot;, &quot;75&quot;, &quot;100&quot;) ) + scale_x_continuous( name=&quot;Evaluation&quot;, labels = c(&#39;0.0e+0&#39;, &#39;5.0e+8&#39;,&#39;1.0e+9&#39;,&#39;1.5e+9&#39;), limits = c(0,1520000000) ) + scale_shape_manual(values=SHAPE)+ scale_colour_manual(values = cb_palette) + scale_fill_manual(values = cb_palette) + ggtitle(&#39;Satisfactory trait coverage over time&#39;)+ p_theme + guides( shape=guide_legend(nrow=2, title.position = &quot;left&quot;, title = &#39;Population\\nSize&#39;), color=guide_legend(nrow=2, title.position = &quot;left&quot;, title = &#39;Population\\nSize&#39;), fill=guide_legend(nrow=2, title.position = &quot;left&quot;, title = &#39;Population\\nSize&#39;) ) 5.3.2 Best satisfactory trait coverage found throughout run Satisfactory trait coverage of the best population found throughout an evolutionary run. ggplot(best, aes(x = pop_size, y = coverage, color = pop_size, fill = pop_size, shape = pop_size)) + geom_flat_violin(position = position_nudge(x = .1, y = 0), scale = &#39;width&#39;, alpha = 0.2, width = 1.5) + geom_boxplot(color = &#39;black&#39;, width = .07, outlier.shape = NA, alpha = 0.0, size = 1.0, position = position_nudge(x = .16, y = 0)) + geom_point(position = position_jitter(width = 0.02, height = 0.0001), size = 1.5, alpha = 1.0) + scale_y_continuous( name=&quot;Coverage&quot;, limits=c(0, 100), breaks=seq(0,100, 25), labels=c(&quot;0&quot;, &quot;25&quot;, &quot;50&quot;, &quot;75&quot;, &quot;100&quot;), ) + scale_x_discrete( name=&quot;Population Size&quot; )+ scale_shape_manual(values=SHAPE)+ scale_colour_manual(values = cb_palette, ) + scale_fill_manual(values = cb_palette) + ggtitle(&#39; Best satisfactory coverage&#39;)+ p_theme + coord_flip() + guides( shape=guide_legend(nrow=2, title.position = &quot;left&quot;, title = &#39;Population\\nSize&#39;), color=guide_legend(nrow=2, title.position = &quot;left&quot;, title = &#39;Population\\nSize&#39;), fill=guide_legend(nrow=2, title.position = &quot;left&quot;, title = &#39;Population\\nSize&#39;) ) 5.3.2.1 Summary statistics best %&gt;% group_by(pop_size) %&gt;% dplyr::summarise( count = n(), na_cnt = sum(is.na(coverage)), min = min(coverage, na.rm = TRUE), median = median(coverage, na.rm = TRUE), mean = mean(coverage, na.rm = TRUE), max = max(coverage, na.rm = TRUE), IQR = IQR(coverage, na.rm = TRUE) ) ## # A tibble: 5 × 8 ## pop_size count na_cnt min median mean max IQR ## &lt;fct&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 50 50 0 4 5 4.94 7 1 ## 2 100 50 0 7 8 8.38 10 1 ## 3 500 50 0 33 36 36.5 41 3 ## 4 1000 50 0 57 63 62.3 69 3 ## 5 5000 50 0 86 90 90.0 96 3.75 5.3.2.2 Kruskal-Wallis test kruskal.test(coverage ~ pop_size, data = best) ## ## Kruskal-Wallis rank sum test ## ## data: coverage by pop_size ## Kruskal-Wallis chi-squared = 239.68, df = 4, ## p-value &lt; 2.2e-16 5.3.2.3 Pairwise wilcoxon test pairwise.wilcox.test(x = best$coverage, g = best$pop_size, p.adjust.method = &quot;bonferroni&quot;, paired = FALSE, conf.int = FALSE, alternative = &#39;g&#39;) ## ## Pairwise comparisons using Wilcoxon rank sum test with continuity correction ## ## data: best$coverage and best$pop_size ## ## 50 100 500 1000 ## 100 &lt;2e-16 - - - ## 500 &lt;2e-16 &lt;2e-16 - - ## 1000 &lt;2e-16 &lt;2e-16 &lt;2e-16 - ## 5000 &lt;2e-16 &lt;2e-16 &lt;2e-16 &lt;2e-16 ## ## P value adjustment method: bonferroni "],["contradictory-objectives-300-results.html", "Chapter 6 Contradictory objectives 300 results 6.1 Analysis setup 6.2 Activation gene coverage 6.3 Satisfactory trait coverage", " Chapter 6 Contradictory objectives 300 results Here we report the activation gene coverage and satisfactory trait coverage was found on the contradictory objectives diagnostic. 50 replicates were conducted for each population size explored. Activation gene coverage is calculated by finding all the unique activation genes found within a given population. Satisfactory trait coverage is calculated by finding all the unique satisfactory traits found within a given population. 6.1 Analysis setup library(ggplot2) library(cowplot) library(dplyr) library(PupillometryR) # over time data over_time &lt;- read.csv(&quot;../Paper_Data/Contradictory-300/ot.csv&quot;, header = TRUE, stringsAsFactors = FALSE) over_time$pop_size &lt;- factor(over_time$pop_size, levels = NAMES) # best performance data best &lt;- read.csv(&#39;../Paper_Data/Contradictory-300/best.csv&#39;, header = TRUE, stringsAsFactors = FALSE) best$pop_size &lt;- factor(best$pop_size, levels = NAMES) 6.2 Activation gene coverage 6.2.1 Coverage over time Performance of the best solution in the population at each generation over time. # aggregate lines = over_time %&gt;% group_by(pop_size, eval) %&gt;% dplyr::summarise( min = min(activation_coverage), mean = mean(activation_coverage), max = max(activation_coverage) ) lines$pop_size &lt;- factor(lines$pop_size, levels = NAMES) ggplot(lines, aes(x=eval, y=mean, group = pop_size, fill = pop_size, color = pop_size, shape = pop_size)) + geom_ribbon(aes(ymin = min, ymax = max), alpha = 0.1) + geom_line(linewidth = 0.5) + geom_point(data = filter(lines, eval %% 100000000 == 0 &amp; eval != 0), size = 1.0, stroke = 2.0, alpha = 1.0) + scale_y_continuous( name=&quot;Coverage&quot;, limits=c(0, 100), breaks=seq(0,100, 25), labels=c(&quot;0&quot;, &quot;25&quot;, &quot;50&quot;, &quot;75&quot;, &quot;100&quot;) ) + scale_x_continuous( name=&quot;Evaluation&quot;, labels = c(&#39;0.0e+0&#39;, &#39;5.0e+8&#39;,&#39;1.0e+9&#39;,&#39;1.5e+9&#39;), limits = c(0,1530000000) ) + scale_shape_manual(values=SHAPE)+ scale_colour_manual(values = cb_palette) + scale_fill_manual(values = cb_palette) + ggtitle(&#39;Activation gene over time&#39;)+ p_theme + guides( shape=guide_legend(nrow=2, title.position = &quot;left&quot;, title = &#39;Population\\nSize&#39;), color=guide_legend(nrow=2, title.position = &quot;left&quot;, title = &#39;Population\\nSize&#39;), fill=guide_legend(nrow=2, title.position = &quot;left&quot;, title = &#39;Population\\nSize&#39;) ) 6.3 Satisfactory trait coverage 6.3.1 Coverage over time Satisfactory trait coverage over time. # aggregate lines = over_time %&gt;% group_by(pop_size, eval) %&gt;% dplyr::summarise( min = min(satisfactory_coverage), mean = mean(satisfactory_coverage), max = max(satisfactory_coverage) ) lines$pop_size &lt;- factor(lines$pop_size, levels = NAMES) ggplot(lines, aes(x=eval, y=mean, group = pop_size, fill = pop_size, color = pop_size, shape = pop_size)) + geom_ribbon(aes(ymin = min, ymax = max), alpha = 0.1) + geom_line(linewidth = 0.5) + geom_point(data = filter(lines, eval %% 100000000 == 0 &amp; eval != 0), size = 1.0, stroke = 2.0, alpha = 1.0) + scale_y_continuous( name=&quot;Coverage&quot;, limits=c(0, 75), breaks=seq(0,75, 25), labels=c(&quot;0&quot;, &quot;25&quot;, &quot;50&quot;, &quot;75&quot;) ) + scale_x_continuous( name=&quot;Evaluation&quot;, labels = c(&#39;0.0e+0&#39;, &#39;5.0e+8&#39;,&#39;1.0e+9&#39;,&#39;1.5e+9&#39;), limits = c(0,1530000000) ) + scale_shape_manual(values=SHAPE)+ scale_colour_manual(values = cb_palette) + scale_fill_manual(values = cb_palette) + ggtitle(&#39;Satisfactory trait coverage over time&#39;)+ p_theme + guides( shape=guide_legend(nrow=2, title.position = &quot;left&quot;, title = &#39;Population\\nSize&#39;), color=guide_legend(nrow=2, title.position = &quot;left&quot;, title = &#39;Population\\nSize&#39;), fill=guide_legend(nrow=2, title.position = &quot;left&quot;, title = &#39;Population\\nSize&#39;) ) 6.3.2 Best satisfactory trait coverage found throughout run Satisfactory trait coverage of the best population found throughout an evolutionary run. ggplot(best, aes(x = pop_size, y = coverage, color = pop_size, fill = pop_size, shape = pop_size)) + geom_flat_violin(position = position_nudge(x = .1, y = 0), scale = &#39;width&#39;, alpha = 0.2, width = 1.5) + geom_boxplot(color = &#39;black&#39;, width = .07, outlier.shape = NA, alpha = 0.0, size = 1.0, position = position_nudge(x = .16, y = 0)) + geom_point(position = position_jitter(width = 0.02, height = 0.0001), size = 1.5, alpha = 1.0) + scale_y_continuous( name=&quot;Coverage&quot;, limits=c(0, 75), breaks=seq(0,75, 25), labels=c(&quot;0&quot;, &quot;25&quot;, &quot;50&quot;, &quot;75&quot;) ) + scale_x_discrete( name=&quot;Population Size&quot; )+ scale_shape_manual(values=SHAPE)+ scale_colour_manual(values = cb_palette, ) + scale_fill_manual(values = cb_palette) + ggtitle(&#39;Best satisfactory coverage&#39;)+ p_theme + coord_flip() + guides( shape=guide_legend(nrow=2, title.position = &quot;left&quot;, title = &#39;Population\\nSize&#39;), color=guide_legend(nrow=2, title.position = &quot;left&quot;, title = &#39;Population\\nSize&#39;), fill=guide_legend(nrow=2, title.position = &quot;left&quot;, title = &#39;Population\\nSize&#39;) ) 6.3.2.1 Summary statistics best %&gt;% group_by(pop_size) %&gt;% dplyr::summarise( count = n(), na_cnt = sum(is.na(coverage)), min = min(coverage, na.rm = TRUE), median = median(coverage, na.rm = TRUE), mean = mean(coverage, na.rm = TRUE), max = max(coverage, na.rm = TRUE), IQR = IQR(coverage, na.rm = TRUE) ) ## # A tibble: 5 × 8 ## pop_size count na_cnt min median mean max IQR ## &lt;fct&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 50 50 0 3 4.5 4.46 5 1 ## 2 100 50 0 7 8 8.3 10 1 ## 3 500 50 0 35 38 38.1 42 2 ## 4 1000 50 0 57 63 63.0 70 4 ## 5 5000 50 0 59 67 67.5 74 5.75 6.3.2.2 Kruskal-Wallis test kruskal.test(coverage ~ pop_size, data = best) ## ## Kruskal-Wallis rank sum test ## ## data: coverage by pop_size ## Kruskal-Wallis chi-squared = 233.56, df = 4, ## p-value &lt; 2.2e-16 6.3.2.3 Pairwise wilcoxon test pairwise.wilcox.test(x = best$coverage, g = best$pop_size, p.adjust.method = &quot;bonferroni&quot;, paired = FALSE, conf.int = FALSE, alternative = &#39;g&#39;) ## ## Pairwise comparisons using Wilcoxon rank sum test with continuity correction ## ## data: best$coverage and best$pop_size ## ## 50 100 500 1000 ## 100 &lt; 2e-16 - - - ## 500 &lt; 2e-16 &lt; 2e-16 - - ## 1000 &lt; 2e-16 &lt; 2e-16 &lt; 2e-16 - ## 5000 &lt; 2e-16 &lt; 2e-16 &lt; 2e-16 2.3e-08 ## ## P value adjustment method: bonferroni "],["contradictory-objectives-500-results.html", "Chapter 7 Contradictory objectives 500 results 7.1 Analysis setup 7.2 Activation gene coverage 7.3 Satisfactory trait coverage", " Chapter 7 Contradictory objectives 500 results Here we report the activation gene coverage and satisfactory trait coverage was found on the contradictory objectives diagnostic. 50 replicates were conducted for each population size explored. Activation gene coverage is calculated by finding all the unique activation genes found within a given population. Satisfactory trait coverage is calculated by finding all the unique satisfactory traits found within a given population. 7.1 Analysis setup library(ggplot2) library(cowplot) library(dplyr) library(PupillometryR) # over time data over_time &lt;- read.csv(&quot;../Paper_Data/Contradictory-500/ot.csv&quot;, header = TRUE, stringsAsFactors = FALSE) over_time$pop_size &lt;- factor(over_time$pop_size, levels = NAMES) # best performance data best &lt;- read.csv(&#39;../Paper_Data/Contradictory-500/best.csv&#39;, header = TRUE, stringsAsFactors = FALSE) best$pop_size &lt;- factor(best$pop_size, levels = NAMES) 7.2 Activation gene coverage 7.2.1 Coverage over time Performance of the best solution in the population at each generation over time. # aggregate lines = over_time %&gt;% group_by(pop_size, eval) %&gt;% dplyr::summarise( min = min(activation_coverage), mean = mean(activation_coverage), max = max(activation_coverage) ) lines$pop_size &lt;- factor(lines$pop_size, levels = NAMES) ggplot(lines, aes(x=eval, y=mean, group = pop_size, fill = pop_size, color = pop_size, shape = pop_size)) + geom_ribbon(aes(ymin = min, ymax = max), alpha = 0.1) + geom_line(linewidth = 0.5) + geom_point(data = filter(lines, eval %% 100000000 == 0 &amp; eval != 0), size = 1.0, stroke = 2.0, alpha = 1.0) + scale_y_continuous( name=&quot;Coverage&quot;, limits=c(0, 100), breaks=seq(0,100, 25), labels=c(&quot;0&quot;, &quot;25&quot;, &quot;50&quot;, &quot;75&quot;, &quot;100&quot;) ) + scale_x_continuous( name=&quot;Evaluation&quot;, labels = c(&#39;0.0e+0&#39;, &#39;5.0e+8&#39;,&#39;1.0e+9&#39;,&#39;1.5e+9&#39;), limits = c(0,1520000000) ) + scale_shape_manual(values=SHAPE)+ scale_colour_manual(values = cb_palette) + scale_fill_manual(values = cb_palette) + ggtitle(&#39;Activation gene over time&#39;)+ p_theme + guides( shape=guide_legend(nrow=2, title.position = &quot;left&quot;, title = &#39;Population\\nSize&#39;), color=guide_legend(nrow=2, title.position = &quot;left&quot;, title = &#39;Population\\nSize&#39;), fill=guide_legend(nrow=2, title.position = &quot;left&quot;, title = &#39;Population\\nSize&#39;) ) 7.3 Satisfactory trait coverage 7.3.1 Coverage over time Satisfactory trait coverage over time. # aggregate lines = over_time %&gt;% group_by(pop_size, eval) %&gt;% dplyr::summarise( min = min(satisfactory_coverage), mean = mean(satisfactory_coverage), max = max(satisfactory_coverage) ) lines$pop_size &lt;- factor(lines$pop_size, levels = NAMES) ggplot(lines, aes(x=eval, y=mean, group = pop_size, fill = pop_size, color = pop_size, shape = pop_size)) + geom_ribbon(aes(ymin = min, ymax = max), alpha = 0.1) + geom_line(linewidth = 0.5) + geom_point(data = filter(lines, eval %% 100000000 == 0 &amp; eval != 0), size = 1.0, stroke = 2.0, alpha = 1.0) + scale_y_continuous( name=&quot;Coverage&quot;, limits=c(0, 60), breaks=seq(0,60, 15), labels=c(&quot;0&quot;, &quot;15&quot;, &quot;30&quot;, &quot;45&quot;, &quot;60&quot;) ) + scale_x_continuous( name=&quot;Evaluation&quot;, labels = c(&#39;0.0e+0&#39;, &#39;5.0e+8&#39;,&#39;1.0e+9&#39;,&#39;1.5e+9&#39;), limits = c(0,1520000000) ) + scale_shape_manual(values=SHAPE)+ scale_colour_manual(values = cb_palette) + scale_fill_manual(values = cb_palette) + ggtitle(&#39;Satisfactory trait coverage over time&#39;)+ p_theme + guides( shape=guide_legend(nrow=2, title.position = &quot;left&quot;, title = &#39;Population\\nSize&#39;), color=guide_legend(nrow=2, title.position = &quot;left&quot;, title = &#39;Population\\nSize&#39;), fill=guide_legend(nrow=2, title.position = &quot;left&quot;, title = &#39;Population\\nSize&#39;) ) 7.3.2 Best satisfactory trait coverage found throughout run Satisfactory trait coverage of the best population found throughout an evolutionary run. ggplot(best, aes(x = pop_size, y = coverage, color = pop_size, fill = pop_size, shape = pop_size)) + geom_flat_violin(position = position_nudge(x = .1, y = 0), scale = &#39;width&#39;, alpha = 0.2, width = 1.5) + geom_boxplot(color = &#39;black&#39;, width = .07, outlier.shape = NA, alpha = 0.0, size = 1.0, position = position_nudge(x = .16, y = 0)) + geom_point(position = position_jitter(width = 0.02, height = 0.0001), size = 1.5, alpha = 1.0) + scale_y_continuous( name=&quot;Coverage&quot;, limits=c(0, 60), breaks=seq(0,60, 15), labels=c(&quot;0&quot;, &quot;15&quot;, &quot;30&quot;, &quot;45&quot;, &quot;60&quot;) ) + scale_x_discrete( name=&quot;Population Size&quot; )+ scale_shape_manual(values=SHAPE)+ scale_colour_manual(values = cb_palette, ) + scale_fill_manual(values = cb_palette) + ggtitle(&#39; Best satisfactory coverage&#39;)+ p_theme + coord_flip() + guides( shape=guide_legend(nrow=2, title.position = &quot;left&quot;, title = &#39;Population\\nSize&#39;), color=guide_legend(nrow=2, title.position = &quot;left&quot;, title = &#39;Population\\nSize&#39;), fill=guide_legend(nrow=2, title.position = &quot;left&quot;, title = &#39;Population\\nSize&#39;) ) 7.3.2.1 Summary statistics best %&gt;% group_by(pop_size) %&gt;% dplyr::summarise( count = n(), na_cnt = sum(is.na(coverage)), min = min(coverage, na.rm = TRUE), median = median(coverage, na.rm = TRUE), mean = mean(coverage, na.rm = TRUE), max = max(coverage, na.rm = TRUE), IQR = IQR(coverage, na.rm = TRUE) ) ## # A tibble: 5 × 8 ## pop_size count na_cnt min median mean max IQR ## &lt;fct&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 50 50 0 3 4 4.36 5 1 ## 2 100 50 0 7 9 8.62 10 1 ## 3 500 50 0 36 39.5 39.6 44 3 ## 4 1000 50 0 39 46.5 45.7 52 4.75 ## 5 5000 50 0 22 29 28.6 34 4.75 7.3.2.2 Kruskal-Wallis test kruskal.test(coverage ~ pop_size, data = best) ## ## Kruskal-Wallis rank sum test ## ## data: coverage by pop_size ## Kruskal-Wallis chi-squared = 237.63, df = 4, ## p-value &lt; 2.2e-16 7.3.2.3 Pairwise wilcoxon test best$pop_size &lt;- factor(best$pop_size, levels = c(1000,500,5000,100,50)) pairwise.wilcox.test(x = best$coverage, g = best$pop_size, p.adjust.method = &quot;bonferroni&quot;, paired = FALSE, conf.int = FALSE, alternative = &#39;l&#39;) ## ## Pairwise comparisons using Wilcoxon rank sum test with continuity correction ## ## data: best$coverage and best$pop_size ## ## 1000 500 5000 100 ## 500 5.7e-14 - - - ## 5000 &lt; 2e-16 &lt; 2e-16 - - ## 100 &lt; 2e-16 &lt; 2e-16 &lt; 2e-16 - ## 50 &lt; 2e-16 &lt; 2e-16 &lt; 2e-16 &lt; 2e-16 ## ## P value adjustment method: bonferroni "],["references.html", "References", " References "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
