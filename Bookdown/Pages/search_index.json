[["index.html", "Supplemental Material for ‘Hidden Lexicase Selection Parameters: Varying Population Size and Test Case Redundancy with Diagnostic Metrics’ Chapter 1 Introduction 1.1 About our supplemental material 1.2 Contributing authors", " Supplemental Material for ‘Hidden Lexicase Selection Parameters: Varying Population Size and Test Case Redundancy with Diagnostic Metrics’ Jose Guadalupe Hernandez, Anil Kumar Saini, Jason H. Moore 2024-05-15 Chapter 1 Introduction This is not intended as a stand-alone document, but as a companion to our manuscript. 1.1 About our supplemental material As you may have noticed (unless you’re reading a pdf version of this), our supplemental material is hosted using GitHub pages. We compiled our data analyses and supplemental documentation into this nifty web-accessible book using bookdown. The code used for this supplemental material can be found in this GitHub repository. Our supplemental material includes the following: Exploitation rate results (Section 2) Standard contradictory rates results (Section 3) Mutation On and Off results (Section 4) Contradictory rates results w/ 100 redundant test cases (Section 5) Contradictory rates results w/ 200 redundant test cases (Section 6) Contradictory rates results w/ 400 redundant test cases (Section 7) 1.2 Contributing authors Jose Guadalupe Hernandez Anil Kumar Saini Jason H. Moore "],["exploitation-rate-results.html", "Chapter 2 Exploitation rate results 2.1 Analysis setup 2.2 Performance over time 2.3 Best performance evolved 2.4 Evaluation satisfactory solution if found", " Chapter 2 Exploitation rate results Here we report the performance and evaluation a satisfactory solution was found on the exploitation rate diagnostic. 50 replicates were conducted for each population size explored. Performance is defined at the average trait performance, where we collect the best performing solution in each generation over time and the best performing solution evolved. A satisfactory solution is defined as a solution that has a phenotype with all traits greater than or equal to 99.0. 2.1 Analysis setup library(ggplot2) library(cowplot) library(dplyr) library(PupillometryR) # over time data over_time &lt;- read.csv(&quot;../Paper_Data/Exploitation/ot.csv&quot;, header = TRUE, stringsAsFactors = FALSE) over_time$pop_size &lt;- factor(over_time$pop_size, levels = NAMES) # best performance data best &lt;- read.csv(&#39;../Paper_Data/Exploitation/best.csv&#39;, header = TRUE, stringsAsFactors = FALSE) best$pop_size &lt;- factor(best$pop_size, levels = NAMES) # get the data ssf &lt;- read.csv(&#39;../Paper_Data/Exploitation/ssf.csv&#39;, header = TRUE, stringsAsFactors = FALSE) ssf$pop_size &lt;- factor(ssf$pop_size, levels = NAMES) ssf &lt;- filter(ssf, evaluation &lt;= 1.5*10^9) 2.2 Performance over time Performance of the best solution in the population at each generation over time. # aggregate lines = over_time %&gt;% group_by(pop_size, eval) %&gt;% dplyr::summarise( min = min(performance), mean = mean(performance), max = max(performance) ) lines$pop_size &lt;- factor(lines$pop_size, levels = NAMES) ggplot(lines, aes(x=eval, y=mean, group = pop_size, fill = pop_size, color = pop_size, shape = pop_size)) + geom_ribbon(aes(ymin = min, ymax = max), alpha = 0.1) + geom_line(linewidth = 0.5) + geom_point(data = filter(lines, eval %% 100000000 == 0 &amp; eval != 0), size = 1.0, stroke = 2.0, alpha = 1.0) + scale_y_continuous( name=&quot;Average trait score&quot;, limits=c(0, 100), breaks=seq(0,100, 25), labels=c(&quot;0&quot;, &quot;25&quot;, &quot;50&quot;, &quot;75&quot;, &quot;100&quot;) ) + scale_x_continuous( name=&quot;Evaluation&quot;, labels = c(&#39;0.0e+0&#39;, &#39;5.0e+8&#39;,&#39;1.0e+9&#39;,&#39;1.5e+9&#39;), limits = c(0,1520000000) ) + scale_shape_manual(values=SHAPE)+ scale_colour_manual(values = cb_palette) + scale_fill_manual(values = cb_palette) + ggtitle(&#39;Performance over time&#39;)+ p_theme + guides( shape=guide_legend(nrow=2, title.position = &quot;left&quot;, title = &#39;Population\\nSize&#39;), color=guide_legend(nrow=2, title.position = &quot;left&quot;, title = &#39;Population\\nSize&#39;), fill=guide_legend(nrow=2, title.position = &quot;left&quot;, title = &#39;Population\\nSize&#39;) ) 2.3 Best performance evolved Performance of the best solution found throughout the entire evolutionary run. ggplot(best, aes(x = pop_size, y = performance, color = pop_size, fill = pop_size, shape = pop_size)) + geom_flat_violin(position = position_nudge(x = .1, y = 0), scale = &#39;width&#39;, alpha = 0.2, width = 1.5) + geom_boxplot(color = &#39;black&#39;, width = .07, outlier.shape = NA, alpha = 0.0, size = 1.0, position = position_nudge(x = .16, y = 0)) + geom_point(position = position_jitter(width = 0.02, height = 0.0001), size = 1.5, alpha = 1.0) + scale_y_continuous( name=&quot;Average trait score&quot;, limits=c(0, 100), breaks=seq(0,100, 25), labels=c(&quot;0&quot;, &quot;25&quot;, &quot;50&quot;, &quot;75&quot;, &quot;100&quot;) ) + scale_x_discrete( name=&quot;Population Size&quot; )+ scale_shape_manual(values=SHAPE)+ scale_colour_manual(values = cb_palette, ) + scale_fill_manual(values = cb_palette) + ggtitle(&#39;Best performance throughout&#39;)+ p_theme+ coord_flip() + guides( shape=guide_legend(nrow=2, title.position = &quot;left&quot;, title = &#39;Population\\nSize&#39;), color=guide_legend(nrow=2, title.position = &quot;left&quot;, title = &#39;Population\\nSize&#39;), fill=guide_legend(nrow=2, title.position = &quot;left&quot;, title = &#39;Population\\nSize&#39;) ) 2.3.1 Summary statistics best %&gt;% group_by(pop_size) %&gt;% dplyr::summarise( count = n(), na_cnt = sum(is.na(performance)), min = min(performance, na.rm = TRUE), median = median(performance, na.rm = TRUE), mean = mean(performance, na.rm = TRUE), max = max(performance, na.rm = TRUE), IQR = IQR(performance, na.rm = TRUE) ) ## # A tibble: 5 × 8 ## pop_size count na_cnt min median mean max IQR ## &lt;fct&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 50 50 0 99.9 99.9 99.9 99.9 0.0149 ## 2 100 50 0 99.9 99.9 99.9 99.9 0.0166 ## 3 500 50 0 99.9 99.9 99.9 99.9 0.0235 ## 4 1000 50 0 79.0 79.9 80.0 81.8 0.779 ## 5 5000 50 0 19.0 19.4 19.4 20.0 0.299 2.3.2 Kruskal-Wallis test kruskal.test(performance ~ pop_size, data = best) ## ## Kruskal-Wallis rank sum test ## ## data: performance by pop_size ## Kruskal-Wallis chi-squared = 198.29, df = 4, p-value &lt; 2.2e-16 2.3.3 Pairwise wilcoxon test pairwise.wilcox.test(x = best$performance, g = best$pop_size, p.adjust.method = &quot;bonferroni&quot;, paired = FALSE, conf.int = FALSE, alternative = &#39;l&#39;) ## ## Pairwise comparisons using Wilcoxon rank sum test with continuity correction ## ## data: best$performance and best$pop_size ## ## 50 100 500 1000 ## 100 1.00000 - - - ## 500 0.00078 0.00059 - - ## 1000 &lt; 2e-16 &lt; 2e-16 &lt; 2e-16 - ## 5000 &lt; 2e-16 &lt; 2e-16 &lt; 2e-16 &lt; 2e-16 ## ## P value adjustment method: bonferroni 2.4 Evaluation satisfactory solution if found Evaluation a satisfactory solution is found for each population size. ggplot(ssf, aes(x = pop_size, y = evaluation, color = pop_size, fill = pop_size, shape = pop_size)) + geom_flat_violin(position = position_nudge(x = 0.12, y = 0), scale = &#39;width&#39;, alpha = 0.2, width = 1.5) + geom_boxplot(color = &#39;black&#39;, width = .08, outlier.shape = NA, alpha = 0.0, size = 0.8, position = position_nudge(x = .19, y = 0)) + geom_point(position = position_jitter(width = 0.03, height = 0.000001), size = 1.5, alpha = 1.0) + scale_y_continuous( name = &#39;Evaluation&#39;, breaks = c(100000000,500000000,1000000000,1500000000), labels = c(&#39;1.0e+8&#39;, &#39;5.0e+8&#39;,&#39;1.0e+9&#39;,&#39;1.5e+9&#39;), limits = c(100000000,1500000000) ) + scale_x_discrete( name=&quot;Population Size&quot;, )+ scale_shape_manual(values=SHAPE, )+ scale_colour_manual(values = cb_palette, ) + scale_fill_manual(values = cb_palette) + ggtitle(bquote(&#39;Evaluation Satisfactory Solution Found&#39;))+ p_theme + coord_flip() + guides( shape=guide_legend(nrow=2, title.position = &quot;left&quot;, title = &#39;Population\\nSize&#39;), color=guide_legend(nrow=2, title.position = &quot;left&quot;, title = &#39;Population\\nSize&#39;), fill=guide_legend(nrow=2, title.position = &quot;left&quot;, title = &#39;Population\\nSize&#39;) ) 2.4.1 Summary statistics ssf %&gt;% group_by(pop_size) %&gt;% dplyr::summarise( count = n(), na_cnt = sum(is.na(evaluation)), min = min(evaluation, na.rm = TRUE), median = median(evaluation, na.rm = TRUE), mean = mean(evaluation, na.rm = TRUE), max = max(evaluation, na.rm = TRUE), IQR = IQR(evaluation, na.rm = TRUE) ) ## # A tibble: 3 × 8 ## pop_size count na_cnt min median mean max IQR ## &lt;fct&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 50 50 0 135075000 213407500 251829000 803685000 131750000 ## 2 100 50 0 255330000 337500000 364654000 882710000 83672500 ## 3 500 50 0 1156350000 1266325000 1275005000 1441600000 90962500 2.4.2 Kruskal-Wallis test kruskal.test(evaluation ~ pop_size, data = ssf) ## ## Kruskal-Wallis rank sum test ## ## data: evaluation by pop_size ## Kruskal-Wallis chi-squared = 113.38, df = 2, p-value &lt; 2.2e-16 2.4.3 Pairwise wilcoxon test pairwise.wilcox.test(x = ssf$evaluation, g = ssf$pop_size, p.adjust.method = &quot;bonferroni&quot;, paired = FALSE, conf.int = FALSE, alternative = &#39;g&#39;) ## ## Pairwise comparisons using Wilcoxon rank sum test with continuity correction ## ## data: ssf$evaluation and ssf$pop_size ## ## 50 100 ## 100 3.1e-08 - ## 500 &lt; 2e-16 &lt; 2e-16 ## ## P value adjustment method: bonferroni "],["contradictory-objectives-100-results.html", "Chapter 3 Contradictory objectives 100 results 3.1 Analysis setup 3.2 Activation gene coverage 3.3 Satisfactory trait coverage", " Chapter 3 Contradictory objectives 100 results Here we report the activation gene coverage and satisfactory trait coverage was found on the contradictory objectives diagnostic. 50 replicates were conducted for each population size explored. Activation gene coverage is calculated by finding all the unique activation genes found within a given population. Satisfactory trait coverage is calculated by finding all the unique satisfactory traits found within a given population. 3.1 Analysis setup library(ggplot2) library(cowplot) library(dplyr) library(PupillometryR) # over time data over_time &lt;- read.csv(&quot;../Paper_Data/Contradictory-100/ot.csv&quot;, header = TRUE, stringsAsFactors = FALSE) over_time$pop_size &lt;- factor(over_time$pop_size, levels = NAMES) # best performance data best &lt;- read.csv(&#39;../Paper_Data/Contradictory-100/best.csv&#39;, header = TRUE, stringsAsFactors = FALSE) best$pop_size &lt;- factor(best$pop_size, levels = NAMES) 3.2 Activation gene coverage 3.2.1 Coverage over time Performance of the best solution in the population at each generation over time. # aggregate lines = filter(over_time,eval != 0) %&gt;% group_by(pop_size, eval) %&gt;% dplyr::summarise( min = min(activation_coverage), mean = mean(activation_coverage), max = max(activation_coverage) ) lines$pop_size &lt;- factor(lines$pop_size, levels = NAMES) ggplot(lines, aes(x=eval, y=mean, group = pop_size, fill = pop_size, color = pop_size, shape = pop_size)) + geom_ribbon(aes(ymin = min, ymax = max), alpha = 0.1) + geom_line(linewidth = 0.5) + geom_point(data = filter(lines, eval %% 100000000 == 0 &amp; eval != 0), size = 1.0, stroke = 2.0, alpha = 1.0) + scale_y_continuous( name=&quot;Coverage&quot;, limits=c(0, 100), breaks=seq(0,100, 25), labels=c(&quot;0&quot;, &quot;25&quot;, &quot;50&quot;, &quot;75&quot;, &quot;100&quot;) ) + scale_x_continuous( name=&quot;Evaluation&quot;, labels = c(&#39;0.0e+0&#39;, &#39;5.0e+8&#39;,&#39;1.0e+9&#39;,&#39;1.5e+9&#39;), limits = c(0,1520000000) ) + scale_shape_manual(values=SHAPE)+ scale_colour_manual(values = cb_palette) + scale_fill_manual(values = cb_palette) + ggtitle(&#39;Activation gene coverage over time&#39;)+ p_theme + guides( shape=guide_legend(nrow=2, title.position = &quot;left&quot;, title = &#39;Population\\nSize&#39;), color=guide_legend(nrow=2, title.position = &quot;left&quot;, title = &#39;Population\\nSize&#39;), fill=guide_legend(nrow=2, title.position = &quot;left&quot;, title = &#39;Population\\nSize&#39;) ) 3.3 Satisfactory trait coverage 3.3.1 Coverage over time Satisfactory trait coverage over time. # aggregate lines = over_time %&gt;% group_by(pop_size, eval) %&gt;% dplyr::summarise( min = min(satisfactory_coverage), mean = mean(satisfactory_coverage), max = max(satisfactory_coverage) ) lines$pop_size &lt;- factor(lines$pop_size, levels = NAMES) ggplot(lines, aes(x=eval, y=mean, group = pop_size, fill = pop_size, color = pop_size, shape = pop_size)) + geom_ribbon(aes(ymin = min, ymax = max), alpha = 0.1) + geom_line(linewidth = 0.5) + geom_point(data = filter(lines, eval %% 100000000 == 0 &amp; eval != 0), size = 1.0, stroke = 2.0, alpha = 1.0) + scale_y_continuous( name=&quot;Coverage&quot;, limits=c(0, 100), breaks=seq(0,100, 25), labels=c(&quot;0&quot;, &quot;25&quot;, &quot;50&quot;, &quot;75&quot;, &quot;100&quot;) ) + scale_x_continuous( name=&quot;Evaluation&quot;, labels = c(&#39;0.0e+0&#39;, &#39;5.0e+8&#39;,&#39;1.0e+9&#39;,&#39;1.5e+9&#39;), limits = c(0,1520000000) ) + scale_shape_manual(values=SHAPE)+ scale_colour_manual(values = cb_palette) + scale_fill_manual(values = cb_palette) + ggtitle(&#39;Satisfactory trait coverage over time&#39;)+ p_theme + guides( shape=guide_legend(nrow=2, title.position = &quot;left&quot;, title = &#39;Population\\nSize&#39;), color=guide_legend(nrow=2, title.position = &quot;left&quot;, title = &#39;Population\\nSize&#39;), fill=guide_legend(nrow=2, title.position = &quot;left&quot;, title = &#39;Population\\nSize&#39;) ) 3.3.2 Best satisfactory trait coverage found throughout run Satisfactory trait coverage of the best population found throughout an evolutionary run. ggplot(best, aes(x = pop_size, y = coverage, color = pop_size, fill = pop_size, shape = pop_size)) + geom_flat_violin(position = position_nudge(x = .1, y = 0), scale = &#39;width&#39;, alpha = 0.2, width = 1.5) + geom_boxplot(color = &#39;black&#39;, width = .07, outlier.shape = NA, alpha = 0.0, size = 1.0, position = position_nudge(x = .16, y = 0)) + geom_point(position = position_jitter(width = 0.02, height = 0.0001), size = 1.5, alpha = 1.0) + scale_y_continuous( name=&quot;Coverage&quot;, limits=c(0, 100), breaks=seq(0,100, 25), labels=c(&quot;0&quot;, &quot;25&quot;, &quot;50&quot;, &quot;75&quot;, &quot;100&quot;), ) + scale_x_discrete( name=&quot;Population Size&quot; )+ scale_shape_manual(values=SHAPE)+ scale_colour_manual(values = cb_palette, ) + scale_fill_manual(values = cb_palette) + ggtitle(&#39;Best satisfactory coverage&#39;)+ p_theme + coord_flip() + guides( shape=guide_legend(nrow=2, title.position = &quot;left&quot;, title = &#39;Population\\nSize&#39;), color=guide_legend(nrow=2, title.position = &quot;left&quot;, title = &#39;Population\\nSize&#39;), fill=guide_legend(nrow=2, title.position = &quot;left&quot;, title = &#39;Population\\nSize&#39;) ) ## Warning: Removed 26 rows containing missing values (`geom_point()`). 3.3.2.1 Summary statistics best %&gt;% group_by(pop_size) %&gt;% dplyr::summarise( count = n(), na_cnt = sum(is.na(coverage)), min = min(coverage, na.rm = TRUE), median = median(coverage, na.rm = TRUE), mean = mean(coverage, na.rm = TRUE), max = max(coverage, na.rm = TRUE), IQR = IQR(coverage, na.rm = TRUE) ) ## # A tibble: 5 × 8 ## pop_size count na_cnt min median mean max IQR ## &lt;fct&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 50 50 0 7 9 9.36 11 1 ## 2 100 50 0 9 10 10.1 13 1 ## 3 500 50 0 44 47 47.0 51 2 ## 4 1000 50 0 86 90 90.0 94 2 ## 5 5000 50 0 100 100 100 100 0 3.3.2.2 Kruskal-Wallis test kruskal.test(coverage ~ pop_size, data = best) ## ## Kruskal-Wallis rank sum test ## ## data: coverage by pop_size ## Kruskal-Wallis chi-squared = 232.33, df = 4, p-value &lt; 2.2e-16 3.3.2.3 Pairwise wilcoxon test pairwise.wilcox.test(x = best$coverage, g = best$pop_size, p.adjust.method = &quot;bonferroni&quot;, paired = FALSE, conf.int = FALSE, alternative = &#39;g&#39;) ## ## Pairwise comparisons using Wilcoxon rank sum test with continuity correction ## ## data: best$coverage and best$pop_size ## ## 50 100 500 1000 ## 100 0.0019 - - - ## 500 &lt;2e-16 &lt;2e-16 - - ## 1000 &lt;2e-16 &lt;2e-16 &lt;2e-16 - ## 5000 &lt;2e-16 &lt;2e-16 &lt;2e-16 &lt;2e-16 ## ## P value adjustment method: bonferroni "],["mutation-on-and-off.html", "Chapter 4 Mutation On and Off 4.1 Analysis setup 4.2 Population size 100 4.3 Population size 500 4.4 Population size 1000", " Chapter 4 Mutation On and Off Here we report the activation gene coverage and satisfactory trait coverage was found on the contradictory objectives diagnostic for runs with mutation on and with mutation off. 50 replicates were conducted for each population size explored. Activation gene coverage is calculated by finding all the unique activation genes found within a given population. Satisfactory trait coverage is calculated by finding all the unique satisfactory traits found within a given population. 4.1 Analysis setup library(ggplot2) library(cowplot) library(dplyr) library(PupillometryR) MUTATION &lt;- c(&#39;No&#39;,&#39;Yes&#39;) # mutation data m_data_dir &lt;- &#39;../Paper_Data/Mutation-On-Off/On/Contradictory-100/&#39; m_over_time &lt;- read.csv(paste(m_data_dir, &#39;ot.csv&#39;, sep = &quot;&quot;, collapse = NULL), header = TRUE, stringsAsFactors = FALSE) m_over_time$pop_size &lt;- factor(m_over_time$pop_size, levels = NAMES) m_over_time$mutation &lt;- &#39;Yes&#39; # no mutation data n_data_dir &lt;- &#39;../Paper_Data/Mutation-On-Off/Off/Contradictory-100/&#39; n_over_time &lt;- read.csv(paste(n_data_dir, &#39;ot.csv&#39;, sep = &quot;&quot;, collapse = NULL), header = TRUE, stringsAsFactors = FALSE) n_over_time$pop_size &lt;- factor(n_over_time$pop_size, levels = NAMES) n_over_time$mutation &lt;- &#39;No&#39; # combine all data over_time &lt;- rbind(m_over_time,n_over_time) over_time$mutation &lt;- factor(over_time$mutation, levels=MUTATION) 4.2 Population size 100 4.2.1 Activation gene coverage over time Activation gene coverage found in each generation. # aggregate lines = filter(over_time, pop_size == 100 &amp; eval &gt; 0) %&gt;% group_by(mutation, eval) %&gt;% dplyr::summarise( min = min(activation_coverage), mean = mean(activation_coverage), max = max(activation_coverage) ) lines$mutation &lt;- factor(lines$mutation, levels = MUTATION) ggplot(lines, aes(x=eval, y=mean, group = mutation, fill = mutation, color = mutation, shape = mutation)) + geom_ribbon(aes(ymin = min, ymax = max), alpha = 0.1) + geom_line(linewidth = 0.5) + geom_point(data = filter(lines, eval %% 100000000 == 0 &amp; eval != 0), size = 1.0, stroke = 2.0, alpha = 1.0) + scale_y_continuous( name=&quot;Coverage&quot;, ) + scale_x_continuous( name=&quot;Evaluation&quot;, labels = c(&#39;0.0e+0&#39;, &#39;5.0e+8&#39;,&#39;1.0e+9&#39;,&#39;1.5e+9&#39;), limits = c(0,1520000000) ) + scale_shape_manual(values=SHAPE)+ scale_colour_manual(values = cb_palette) + scale_fill_manual(values = cb_palette) + ggtitle(&#39;Activation gene coverage over time&#39;)+ p_theme + guides( shape=guide_legend(nrow=1, title.position = &quot;left&quot;, title = &#39;Mutation&#39;), color=guide_legend(nrow=1, title.position = &quot;left&quot;, title = &#39;Mutation&#39;), fill=guide_legend(nrow=1, title.position = &quot;left&quot;, title = &#39;Mutation&#39;) ) 4.2.2 Final activation gene coverage Activation gene coverage found in the final population. filter(over_time, pop_size == 100 &amp; eval == 1.5 * 10^9) %&gt;% ggplot(., aes(x = mutation, y = activation_coverage, color = mutation, fill = mutation, shape = mutation)) + geom_flat_violin(position = position_nudge(x = .1, y = 0), scale = &#39;width&#39;, alpha = 0.2, width = 1.5) + geom_boxplot(color = &#39;black&#39;, width = .07, outlier.shape = NA, alpha = 0.0, size = 1.0, position = position_nudge(x = .16, y = 0)) + geom_point(position = position_jitter(width = 0.02, height = 0.0001), size = 1.5, alpha = 1.0) + scale_y_continuous( name=&quot;Coverage&quot; ) + scale_x_discrete( name=&quot;Mutation&quot; )+ scale_shape_manual(values=SHAPE)+ scale_colour_manual(values = cb_palette, ) + scale_fill_manual(values = cb_palette) + ggtitle(&#39;Final activation gene coverage&#39;)+ p_theme 4.2.2.1 Summary statistics filter(over_time, pop_size == 100 &amp; eval == 1.5 * 10^9) %&gt;% group_by(mutation) %&gt;% dplyr::summarise( count = n(), na_cnt = sum(is.na(activation_coverage)), min = min(activation_coverage, na.rm = TRUE), median = median(activation_coverage, na.rm = TRUE), mean = mean(activation_coverage, na.rm = TRUE), max = max(activation_coverage, na.rm = TRUE), IQR = IQR(activation_coverage, na.rm = TRUE) ) ## # A tibble: 2 × 8 ## mutation count na_cnt min median mean max IQR ## &lt;fct&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 No 50 0 6 7 7.2 8 0 ## 2 Yes 50 0 6 9 9.08 11 1 4.2.2.2 Wilcoxon test final_100 &lt;- filter(over_time, pop_size == 100 &amp; eval == 1.5 * 10^9) wilcox.test(final_100$activation_coverage ~ final_100$mutation, paired = FALSE, conf.int = FALSE, alternative = &#39;l&#39;) ## ## Wilcoxon rank sum test with continuity correction ## ## data: final_100$activation_coverage by final_100$mutation ## W = 133, p-value = 6.163e-16 ## alternative hypothesis: true location shift is less than 0 4.3 Population size 500 4.3.1 Activation gene coverage over time Activation gene coverage found in each generation. # aggregate lines = filter(over_time, pop_size == 500 &amp; eval &gt; 0) %&gt;% group_by(mutation, eval) %&gt;% dplyr::summarise( min = min(activation_coverage), mean = mean(activation_coverage), max = max(activation_coverage) ) lines$mutation &lt;- factor(lines$mutation, levels = MUTATION) ggplot(lines, aes(x=eval, y=mean, group = mutation, fill = mutation, color = mutation, shape = mutation)) + geom_ribbon(aes(ymin = min, ymax = max), alpha = 0.1) + geom_line(linewidth = 0.5) + geom_point(data = filter(lines, eval %% 100000000 == 0 &amp; eval != 0), size = 1.0, stroke = 2.0, alpha = 1.0) + scale_y_continuous( name=&quot;Coverage&quot;, ) + scale_x_continuous( name=&quot;Evaluation&quot;, labels = c(&#39;0.0e+0&#39;, &#39;5.0e+8&#39;,&#39;1.0e+9&#39;,&#39;1.5e+9&#39;), limits = c(0,1520000000) ) + scale_shape_manual(values=SHAPE)+ scale_colour_manual(values = cb_palette) + scale_fill_manual(values = cb_palette) + ggtitle(&#39;Activation gene coverage over time&#39;)+ p_theme + guides( shape=guide_legend(nrow=1, title.position = &quot;left&quot;, title = &#39;Mutation&#39;), color=guide_legend(nrow=1, title.position = &quot;left&quot;, title = &#39;Mutation&#39;), fill=guide_legend(nrow=1, title.position = &quot;left&quot;, title = &#39;Mutation&#39;) ) 4.3.2 Final activation gene coverage Activation gene coverage found in the final population. filter(over_time, pop_size == 500 &amp; eval == 1.5 * 10^9) %&gt;% ggplot(., aes(x = mutation, y = activation_coverage, color = mutation, fill = mutation, shape = mutation)) + geom_flat_violin(position = position_nudge(x = .1, y = 0), scale = &#39;width&#39;, alpha = 0.2, width = 1.5) + geom_boxplot(color = &#39;black&#39;, width = .07, outlier.shape = NA, alpha = 0.0, size = 1.0, position = position_nudge(x = .16, y = 0)) + geom_point(position = position_jitter(width = 0.02, height = 0.0001), size = 1.5, alpha = 1.0) + scale_y_continuous( name=&quot;Coverage&quot; ) + scale_x_discrete( name=&quot;Mutation&quot; )+ scale_shape_manual(values=SHAPE)+ scale_colour_manual(values = cb_palette, ) + scale_fill_manual(values = cb_palette) + ggtitle(&#39;Final activation gene coverage&#39;)+ p_theme 4.3.2.1 Summary statistics filter(over_time, pop_size == 500 &amp; eval == 1.5 * 10^9) %&gt;% group_by(mutation) %&gt;% dplyr::summarise( count = n(), na_cnt = sum(is.na(activation_coverage)), min = min(activation_coverage, na.rm = TRUE), median = median(activation_coverage, na.rm = TRUE), mean = mean(activation_coverage, na.rm = TRUE), max = max(activation_coverage, na.rm = TRUE), IQR = IQR(activation_coverage, na.rm = TRUE) ) ## # A tibble: 2 × 8 ## mutation count na_cnt min median mean max IQR ## &lt;fct&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 No 50 0 37 39 39.4 42 1.75 ## 2 Yes 50 0 37 40 39.5 42 1 4.3.2.2 Wilcoxon test final_500 &lt;- filter(over_time, pop_size == 500 &amp; eval == 1.5 * 10^9) wilcox.test(final_500$activation_coverage ~ final_100$mutation, paired = FALSE, conf.int = FALSE, alternative = &#39;t&#39;) ## ## Wilcoxon rank sum test with continuity correction ## ## data: final_500$activation_coverage by final_100$mutation ## W = 1164, p-value = 0.5402 ## alternative hypothesis: true location shift is not equal to 0 4.4 Population size 1000 4.4.1 Activation gene coverage over time Activation gene coverage found in each generation. # aggregate lines = filter(over_time, pop_size == 1000 &amp; eval &gt; 0) %&gt;% group_by(mutation, eval) %&gt;% dplyr::summarise( min = min(activation_coverage), mean = mean(activation_coverage), max = max(activation_coverage) ) lines$mutation &lt;- factor(lines$mutation, levels = MUTATION) ggplot(lines, aes(x=eval, y=mean, group = mutation, fill = mutation, color = mutation, shape = mutation)) + geom_ribbon(aes(ymin = min, ymax = max), alpha = 0.1) + geom_line(linewidth = 0.5) + geom_point(data = filter(lines, eval %% 100000000 == 0 &amp; eval != 0), size = 1.0, stroke = 2.0, alpha = 1.0) + scale_y_continuous( name=&quot;Coverage&quot;, ) + scale_x_continuous( name=&quot;Evaluation&quot;, labels = c(&#39;0.0e+0&#39;, &#39;5.0e+8&#39;,&#39;1.0e+9&#39;,&#39;1.5e+9&#39;), limits = c(0,1520000000) ) + scale_shape_manual(values=SHAPE)+ scale_colour_manual(values = cb_palette) + scale_fill_manual(values = cb_palette) + ggtitle(&#39;Activation gene coverage over time&#39;)+ p_theme + guides( shape=guide_legend(nrow=1, title.position = &quot;left&quot;, title = &#39;Mutation&#39;), color=guide_legend(nrow=1, title.position = &quot;left&quot;, title = &#39;Mutation&#39;), fill=guide_legend(nrow=1, title.position = &quot;left&quot;, title = &#39;Mutation&#39;) ) 4.4.2 Final activation gene coverage Activation gene coverage found in the final population. filter(over_time, pop_size == 1000 &amp; eval == 1.5 * 10^9) %&gt;% ggplot(., aes(x = mutation, y = activation_coverage, color = mutation, fill = mutation, shape = mutation)) + geom_flat_violin(position = position_nudge(x = .1, y = 0), scale = &#39;width&#39;, alpha = 0.2, width = 1.5) + geom_boxplot(color = &#39;black&#39;, width = .07, outlier.shape = NA, alpha = 0.0, size = 1.0, position = position_nudge(x = .16, y = 0)) + geom_point(position = position_jitter(width = 0.02, height = 0.0001), size = 1.5, alpha = 1.0) + scale_y_continuous( name=&quot;Coverage&quot; ) + scale_x_discrete( name=&quot;Mutation&quot; )+ scale_shape_manual(values=SHAPE)+ scale_colour_manual(values = cb_palette, ) + scale_fill_manual(values = cb_palette) + ggtitle(&#39;Final activation gene coverage&#39;)+ p_theme 4.4.2.1 Summary statistics filter(over_time, pop_size == 1000 &amp; eval == 1.5 * 10^9) %&gt;% group_by(mutation) %&gt;% dplyr::summarise( count = n(), na_cnt = sum(is.na(activation_coverage)), min = min(activation_coverage, na.rm = TRUE), median = median(activation_coverage, na.rm = TRUE), mean = mean(activation_coverage, na.rm = TRUE), max = max(activation_coverage, na.rm = TRUE), IQR = IQR(activation_coverage, na.rm = TRUE) ) ## # A tibble: 2 × 8 ## mutation count na_cnt min median mean max IQR ## &lt;fct&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 No 50 0 79 83 82.8 86 2 ## 2 Yes 50 0 79 82 82.2 86 2 4.4.2.2 Wilcoxon test final_1000 &lt;- filter(over_time, pop_size == 1000 &amp; eval == 1.5 * 10^9) wilcox.test(final_1000$activation_coverage ~ final_100$mutation, paired = FALSE, conf.int = FALSE, alternative = &#39;t&#39;) ## ## Wilcoxon rank sum test with continuity correction ## ## data: final_1000$activation_coverage by final_100$mutation ## W = 1480, p-value = 0.1079 ## alternative hypothesis: true location shift is not equal to 0 "],["contradictory-objectives-200-results.html", "Chapter 5 Contradictory objectives 200 results 5.1 Analysis setup 5.2 Activation gene coverage 5.3 Satisfactory trait coverage", " Chapter 5 Contradictory objectives 200 results Here we report the activation gene coverage and satisfactory trait coverage was found on the contradictory objectives diagnostic. 50 replicates were conducted for each population size explored. Activation gene coverage is calculated by finding all the unique activation genes found within a given population. Satisfactory trait coverage is calculated by finding all the unique satisfactory traits found within a given population. 5.1 Analysis setup library(ggplot2) library(cowplot) library(dplyr) library(PupillometryR) # over time data over_time &lt;- read.csv(&quot;../Paper_Data/Contradictory-200/ot.csv&quot;, header = TRUE, stringsAsFactors = FALSE) over_time$pop_size &lt;- factor(over_time$pop_size, levels = NAMES) # best performance data best &lt;- read.csv(&#39;../Paper_Data/Contradictory-200/best.csv&#39;, header = TRUE, stringsAsFactors = FALSE) best$pop_size &lt;- factor(best$pop_size, levels = NAMES) 5.2 Activation gene coverage 5.2.1 Coverage over time Performance of the best solution in the population at each generation over time. # aggregate lines = filter(over_time,eval != 0) %&gt;% group_by(pop_size, eval) %&gt;% dplyr::summarise( min = min(activation_coverage), mean = mean(activation_coverage), max = max(activation_coverage) ) lines$pop_size &lt;- factor(lines$pop_size, levels = NAMES) ggplot(lines, aes(x=eval, y=mean, group = pop_size, fill = pop_size, color = pop_size, shape = pop_size)) + geom_ribbon(aes(ymin = min, ymax = max), alpha = 0.1) + geom_line(linewidth = 0.5) + geom_point(data = filter(lines, eval %% 100000000 == 0 &amp; eval != 0), size = 1.0, stroke = 2.0, alpha = 1.0) + scale_y_continuous( name=&quot;Coverage&quot;, limits=c(0, 100), breaks=seq(0,100, 25), labels=c(&quot;0&quot;, &quot;25&quot;, &quot;50&quot;, &quot;75&quot;, &quot;100&quot;) ) + scale_x_continuous( name=&quot;Evaluation&quot;, labels = c(&#39;0.0e+0&#39;, &#39;5.0e+8&#39;,&#39;1.0e+9&#39;,&#39;1.5e+9&#39;), limits = c(0,1520000000) ) + scale_shape_manual(values=SHAPE)+ scale_colour_manual(values = cb_palette) + scale_fill_manual(values = cb_palette) + ggtitle(&#39;Activation gene coverage over time&#39;)+ p_theme + guides( shape=guide_legend(nrow=2, title.position = &quot;left&quot;, title = &#39;Population\\nSize&#39;), color=guide_legend(nrow=2, title.position = &quot;left&quot;, title = &#39;Population\\nSize&#39;), fill=guide_legend(nrow=2, title.position = &quot;left&quot;, title = &#39;Population\\nSize&#39;) ) 5.3 Satisfactory trait coverage 5.3.1 Coverage over time Satisfactory trait coverage over time. # aggregate lines = over_time %&gt;% group_by(pop_size, eval) %&gt;% dplyr::summarise( min = min(satisfactory_coverage), mean = mean(satisfactory_coverage), max = max(satisfactory_coverage) ) lines$pop_size &lt;- factor(lines$pop_size, levels = NAMES) ggplot(lines, aes(x=eval, y=mean, group = pop_size, fill = pop_size, color = pop_size, shape = pop_size)) + geom_ribbon(aes(ymin = min, ymax = max), alpha = 0.1) + geom_line(linewidth = 0.5) + geom_point(data = filter(lines, eval %% 100000000 == 0 &amp; eval != 0), size = 1.0, stroke = 2.0, alpha = 1.0) + scale_y_continuous( name=&quot;Coverage&quot;, limits=c(0, 100), breaks=seq(0,100, 25), labels=c(&quot;0&quot;, &quot;25&quot;, &quot;50&quot;, &quot;75&quot;, &quot;100&quot;) ) + scale_x_continuous( name=&quot;Evaluation&quot;, labels = c(&#39;0.0e+0&#39;, &#39;5.0e+8&#39;,&#39;1.0e+9&#39;,&#39;1.5e+9&#39;), limits = c(0,1520000000) ) + scale_shape_manual(values=SHAPE)+ scale_colour_manual(values = cb_palette) + scale_fill_manual(values = cb_palette) + ggtitle(&#39;Satisfactory trait coverage over time&#39;)+ p_theme + guides( shape=guide_legend(nrow=2, title.position = &quot;left&quot;, title = &#39;Population\\nSize&#39;), color=guide_legend(nrow=2, title.position = &quot;left&quot;, title = &#39;Population\\nSize&#39;), fill=guide_legend(nrow=2, title.position = &quot;left&quot;, title = &#39;Population\\nSize&#39;) ) 5.3.2 Best satisfactory trait coverage found throughout run Satisfactory trait coverage of the best population found throughout an evolutionary run. ggplot(best, aes(x = pop_size, y = coverage, color = pop_size, fill = pop_size, shape = pop_size)) + geom_flat_violin(position = position_nudge(x = .1, y = 0), scale = &#39;width&#39;, alpha = 0.2, width = 1.5) + geom_boxplot(color = &#39;black&#39;, width = .07, outlier.shape = NA, alpha = 0.0, size = 1.0, position = position_nudge(x = .16, y = 0)) + geom_point(position = position_jitter(width = 0.02, height = 0.0001), size = 1.5, alpha = 1.0) + scale_y_continuous( name=&quot;Coverage&quot;, limits=c(0, 100), breaks=seq(0,100, 25), labels=c(&quot;0&quot;, &quot;25&quot;, &quot;50&quot;, &quot;75&quot;, &quot;100&quot;), ) + scale_x_discrete( name=&quot;Population Size&quot; )+ scale_shape_manual(values=SHAPE)+ scale_colour_manual(values = cb_palette, ) + scale_fill_manual(values = cb_palette) + ggtitle(&#39;Best satisfactory coverage&#39;)+ p_theme + coord_flip() + guides( shape=guide_legend(nrow=2, title.position = &quot;left&quot;, title = &#39;Population\\nSize&#39;), color=guide_legend(nrow=2, title.position = &quot;left&quot;, title = &#39;Population\\nSize&#39;), fill=guide_legend(nrow=2, title.position = &quot;left&quot;, title = &#39;Population\\nSize&#39;) ) 5.3.2.1 Summary statistics best %&gt;% group_by(pop_size) %&gt;% dplyr::summarise( count = n(), na_cnt = sum(is.na(coverage)), min = min(coverage, na.rm = TRUE), median = median(coverage, na.rm = TRUE), mean = mean(coverage, na.rm = TRUE), max = max(coverage, na.rm = TRUE), IQR = IQR(coverage, na.rm = TRUE) ) ## # A tibble: 5 × 8 ## pop_size count na_cnt min median mean max IQR ## &lt;fct&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 50 50 0 4 5 4.94 7 1 ## 2 100 50 0 7 8 8.38 10 1 ## 3 500 50 0 33 36 36.5 41 3 ## 4 1000 50 0 57 63 62.3 69 3 ## 5 5000 50 0 86 90 90.0 96 3.75 5.3.2.2 Kruskal-Wallis test kruskal.test(coverage ~ pop_size, data = best) ## ## Kruskal-Wallis rank sum test ## ## data: coverage by pop_size ## Kruskal-Wallis chi-squared = 239.68, df = 4, p-value &lt; 2.2e-16 5.3.2.3 Pairwise wilcoxon test pairwise.wilcox.test(x = best$coverage, g = best$pop_size, p.adjust.method = &quot;bonferroni&quot;, paired = FALSE, conf.int = FALSE, alternative = &#39;g&#39;) ## ## Pairwise comparisons using Wilcoxon rank sum test with continuity correction ## ## data: best$coverage and best$pop_size ## ## 50 100 500 1000 ## 100 &lt;2e-16 - - - ## 500 &lt;2e-16 &lt;2e-16 - - ## 1000 &lt;2e-16 &lt;2e-16 &lt;2e-16 - ## 5000 &lt;2e-16 &lt;2e-16 &lt;2e-16 &lt;2e-16 ## ## P value adjustment method: bonferroni "],["contradictory-objectives-300-results.html", "Chapter 6 Contradictory objectives 300 results 6.1 Analysis setup 6.2 Activation gene coverage 6.3 Satisfactory trait coverage", " Chapter 6 Contradictory objectives 300 results Here we report the activation gene coverage and satisfactory trait coverage was found on the contradictory objectives diagnostic. 50 replicates were conducted for each population size explored. Activation gene coverage is calculated by finding all the unique activation genes found within a given population. Satisfactory trait coverage is calculated by finding all the unique satisfactory traits found within a given population. 6.1 Analysis setup library(ggplot2) library(cowplot) library(dplyr) library(PupillometryR) # over time data over_time &lt;- read.csv(&quot;../Paper_Data/Contradictory-300/ot.csv&quot;, header = TRUE, stringsAsFactors = FALSE) over_time$pop_size &lt;- factor(over_time$pop_size, levels = NAMES) # best performance data best &lt;- read.csv(&#39;../Paper_Data/Contradictory-300/best.csv&#39;, header = TRUE, stringsAsFactors = FALSE) best$pop_size &lt;- factor(best$pop_size, levels = NAMES) 6.2 Activation gene coverage 6.2.1 Coverage over time Performance of the best solution in the population at each generation over time. # aggregate lines = filter(over_time,eval != 0) %&gt;% group_by(pop_size, eval) %&gt;% dplyr::summarise( min = min(activation_coverage), mean = mean(activation_coverage), max = max(activation_coverage) ) lines$pop_size &lt;- factor(lines$pop_size, levels = NAMES) ggplot(lines, aes(x=eval, y=mean, group = pop_size, fill = pop_size, color = pop_size, shape = pop_size)) + geom_ribbon(aes(ymin = min, ymax = max), alpha = 0.1) + geom_line(linewidth = 0.5) + geom_point(data = filter(lines, eval %% 100000000 == 0 &amp; eval != 0), size = 1.0, stroke = 2.0, alpha = 1.0) + scale_y_continuous( name=&quot;Coverage&quot;, limits=c(0, 100), breaks=seq(0,100, 25), labels=c(&quot;0&quot;, &quot;25&quot;, &quot;50&quot;, &quot;75&quot;, &quot;100&quot;) ) + scale_x_continuous( name=&quot;Evaluation&quot;, labels = c(&#39;0.0e+0&#39;, &#39;5.0e+8&#39;,&#39;1.0e+9&#39;,&#39;1.5e+9&#39;), limits = c(0,1530000000) ) + scale_shape_manual(values=SHAPE)+ scale_colour_manual(values = cb_palette) + scale_fill_manual(values = cb_palette) + ggtitle(&#39;Activation gene coverage over time&#39;)+ p_theme + guides( shape=guide_legend(nrow=2, title.position = &quot;left&quot;, title = &#39;Population\\nSize&#39;), color=guide_legend(nrow=2, title.position = &quot;left&quot;, title = &#39;Population\\nSize&#39;), fill=guide_legend(nrow=2, title.position = &quot;left&quot;, title = &#39;Population\\nSize&#39;) ) 6.3 Satisfactory trait coverage 6.3.1 Coverage over time Satisfactory trait coverage over time. # aggregate lines = over_time %&gt;% group_by(pop_size, eval) %&gt;% dplyr::summarise( min = min(satisfactory_coverage), mean = mean(satisfactory_coverage), max = max(satisfactory_coverage) ) lines$pop_size &lt;- factor(lines$pop_size, levels = NAMES) ggplot(lines, aes(x=eval, y=mean, group = pop_size, fill = pop_size, color = pop_size, shape = pop_size)) + geom_ribbon(aes(ymin = min, ymax = max), alpha = 0.1) + geom_line(linewidth = 0.5) + geom_point(data = filter(lines, eval %% 100000000 == 0 &amp; eval != 0), size = 1.0, stroke = 2.0, alpha = 1.0) + scale_y_continuous( name=&quot;Coverage&quot;, limits=c(0, 75), breaks=seq(0,75, 25), labels=c(&quot;0&quot;, &quot;25&quot;, &quot;50&quot;, &quot;75&quot;) ) + scale_x_continuous( name=&quot;Evaluation&quot;, labels = c(&#39;0.0e+0&#39;, &#39;5.0e+8&#39;,&#39;1.0e+9&#39;,&#39;1.5e+9&#39;), limits = c(0,1530000000) ) + scale_shape_manual(values=SHAPE)+ scale_colour_manual(values = cb_palette) + scale_fill_manual(values = cb_palette) + ggtitle(&#39;Satisfactory trait coverage over time&#39;)+ p_theme + guides( shape=guide_legend(nrow=2, title.position = &quot;left&quot;, title = &#39;Population\\nSize&#39;), color=guide_legend(nrow=2, title.position = &quot;left&quot;, title = &#39;Population\\nSize&#39;), fill=guide_legend(nrow=2, title.position = &quot;left&quot;, title = &#39;Population\\nSize&#39;) ) 6.3.2 Best satisfactory trait coverage found throughout run Satisfactory trait coverage of the best population found throughout an evolutionary run. ggplot(best, aes(x = pop_size, y = coverage, color = pop_size, fill = pop_size, shape = pop_size)) + geom_flat_violin(position = position_nudge(x = .1, y = 0), scale = &#39;width&#39;, alpha = 0.2, width = 1.5) + geom_boxplot(color = &#39;black&#39;, width = .07, outlier.shape = NA, alpha = 0.0, size = 1.0, position = position_nudge(x = .16, y = 0)) + geom_point(position = position_jitter(width = 0.02, height = 0.0001), size = 1.5, alpha = 1.0) + scale_y_continuous( name=&quot;Coverage&quot;, limits=c(0, 75), breaks=seq(0,75, 25), labels=c(&quot;0&quot;, &quot;25&quot;, &quot;50&quot;, &quot;75&quot;) ) + scale_x_discrete( name=&quot;Population Size&quot; )+ scale_shape_manual(values=SHAPE)+ scale_colour_manual(values = cb_palette, ) + scale_fill_manual(values = cb_palette) + ggtitle(&#39;Best satisfactory coverage&#39;)+ p_theme + coord_flip() + guides( shape=guide_legend(nrow=2, title.position = &quot;left&quot;, title = &#39;Population\\nSize&#39;), color=guide_legend(nrow=2, title.position = &quot;left&quot;, title = &#39;Population\\nSize&#39;), fill=guide_legend(nrow=2, title.position = &quot;left&quot;, title = &#39;Population\\nSize&#39;) ) 6.3.2.1 Summary statistics best %&gt;% group_by(pop_size) %&gt;% dplyr::summarise( count = n(), na_cnt = sum(is.na(coverage)), min = min(coverage, na.rm = TRUE), median = median(coverage, na.rm = TRUE), mean = mean(coverage, na.rm = TRUE), max = max(coverage, na.rm = TRUE), IQR = IQR(coverage, na.rm = TRUE) ) ## # A tibble: 5 × 8 ## pop_size count na_cnt min median mean max IQR ## &lt;fct&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 50 50 0 3 4.5 4.46 5 1 ## 2 100 50 0 7 8 8.3 10 1 ## 3 500 50 0 35 38 38.1 42 2 ## 4 1000 50 0 57 63 63.0 70 4 ## 5 5000 50 0 59 67 67.5 74 5.75 6.3.2.2 Kruskal-Wallis test kruskal.test(coverage ~ pop_size, data = best) ## ## Kruskal-Wallis rank sum test ## ## data: coverage by pop_size ## Kruskal-Wallis chi-squared = 233.56, df = 4, p-value &lt; 2.2e-16 6.3.2.3 Pairwise wilcoxon test pairwise.wilcox.test(x = best$coverage, g = best$pop_size, p.adjust.method = &quot;bonferroni&quot;, paired = FALSE, conf.int = FALSE, alternative = &#39;g&#39;) ## ## Pairwise comparisons using Wilcoxon rank sum test with continuity correction ## ## data: best$coverage and best$pop_size ## ## 50 100 500 1000 ## 100 &lt; 2e-16 - - - ## 500 &lt; 2e-16 &lt; 2e-16 - - ## 1000 &lt; 2e-16 &lt; 2e-16 &lt; 2e-16 - ## 5000 &lt; 2e-16 &lt; 2e-16 &lt; 2e-16 2.3e-08 ## ## P value adjustment method: bonferroni "],["contradictory-objectives-500-results.html", "Chapter 7 Contradictory objectives 500 results 7.1 Analysis setup 7.2 Activation gene coverage 7.3 Satisfactory trait coverage", " Chapter 7 Contradictory objectives 500 results Here we report the activation gene coverage and satisfactory trait coverage was found on the contradictory objectives diagnostic. 50 replicates were conducted for each population size explored. Activation gene coverage is calculated by finding all the unique activation genes found within a given population. Satisfactory trait coverage is calculated by finding all the unique satisfactory traits found within a given population. 7.1 Analysis setup library(ggplot2) library(cowplot) library(dplyr) library(PupillometryR) # over time data over_time &lt;- read.csv(&quot;../Paper_Data/Contradictory-500/ot.csv&quot;, header = TRUE, stringsAsFactors = FALSE) over_time$pop_size &lt;- factor(over_time$pop_size, levels = NAMES) # best performance data best &lt;- read.csv(&#39;../Paper_Data/Contradictory-500/best.csv&#39;, header = TRUE, stringsAsFactors = FALSE) best$pop_size &lt;- factor(best$pop_size, levels = NAMES) 7.2 Activation gene coverage 7.2.1 Coverage over time Performance of the best solution in the population at each generation over time. lines = filter(over_time,eval != 0) %&gt;% group_by(pop_size, eval) %&gt;% dplyr::summarise( min = min(activation_coverage), mean = mean(activation_coverage), max = max(activation_coverage) ) lines$pop_size &lt;- factor(lines$pop_size, levels = NAMES) ggplot(lines, aes(x=eval, y=mean, group = pop_size, fill = pop_size, color = pop_size, shape = pop_size)) + geom_ribbon(aes(ymin = min, ymax = max), alpha = 0.1) + geom_line(linewidth = 0.5) + geom_point(data = filter(lines, eval %% 100000000 == 0 &amp; eval != 0), size = 1.0, stroke = 2.0, alpha = 1.0) + scale_y_continuous( name=&quot;Coverage&quot;, limits=c(0, 100), breaks=seq(0,100, 25), labels=c(&quot;0&quot;, &quot;25&quot;, &quot;50&quot;, &quot;75&quot;, &quot;100&quot;) ) + scale_x_continuous( name=&quot;Evaluation&quot;, labels = c(&#39;0.0e+0&#39;, &#39;5.0e+8&#39;,&#39;1.0e+9&#39;,&#39;1.5e+9&#39;), limits = c(0,1520000000) ) + scale_shape_manual(values=SHAPE)+ scale_colour_manual(values = cb_palette) + scale_fill_manual(values = cb_palette) + ggtitle(&#39;Activation gene coverage over time&#39;)+ p_theme + guides( shape=guide_legend(nrow=2, title.position = &quot;left&quot;, title = &#39;Population\\nSize&#39;), color=guide_legend(nrow=2, title.position = &quot;left&quot;, title = &#39;Population\\nSize&#39;), fill=guide_legend(nrow=2, title.position = &quot;left&quot;, title = &#39;Population\\nSize&#39;) ) 7.3 Satisfactory trait coverage 7.3.1 Coverage over time Satisfactory trait coverage over time. # aggregate lines = over_time %&gt;% group_by(pop_size, eval) %&gt;% dplyr::summarise( min = min(satisfactory_coverage), mean = mean(satisfactory_coverage), max = max(satisfactory_coverage) ) lines$pop_size &lt;- factor(lines$pop_size, levels = NAMES) ggplot(lines, aes(x=eval, y=mean, group = pop_size, fill = pop_size, color = pop_size, shape = pop_size)) + geom_ribbon(aes(ymin = min, ymax = max), alpha = 0.1) + geom_line(linewidth = 0.5) + geom_point(data = filter(lines, eval %% 100000000 == 0 &amp; eval != 0), size = 1.0, stroke = 2.0, alpha = 1.0) + scale_y_continuous( name=&quot;Coverage&quot;, limits=c(0, 60), breaks=seq(0,60, 15), labels=c(&quot;0&quot;, &quot;15&quot;, &quot;30&quot;, &quot;45&quot;, &quot;60&quot;) ) + scale_x_continuous( name=&quot;Evaluation&quot;, labels = c(&#39;0.0e+0&#39;, &#39;5.0e+8&#39;,&#39;1.0e+9&#39;,&#39;1.5e+9&#39;), limits = c(0,1520000000) ) + scale_shape_manual(values=SHAPE)+ scale_colour_manual(values = cb_palette) + scale_fill_manual(values = cb_palette) + ggtitle(&#39;Satisfactory trait coverage over time&#39;)+ p_theme + guides( shape=guide_legend(nrow=2, title.position = &quot;left&quot;, title = &#39;Population\\nSize&#39;), color=guide_legend(nrow=2, title.position = &quot;left&quot;, title = &#39;Population\\nSize&#39;), fill=guide_legend(nrow=2, title.position = &quot;left&quot;, title = &#39;Population\\nSize&#39;) ) 7.3.2 Best satisfactory trait coverage found throughout run Satisfactory trait coverage of the best population found throughout an evolutionary run. ggplot(best, aes(x = pop_size, y = coverage, color = pop_size, fill = pop_size, shape = pop_size)) + geom_flat_violin(position = position_nudge(x = .1, y = 0), scale = &#39;width&#39;, alpha = 0.2, width = 1.5) + geom_boxplot(color = &#39;black&#39;, width = .07, outlier.shape = NA, alpha = 0.0, size = 1.0, position = position_nudge(x = .16, y = 0)) + geom_point(position = position_jitter(width = 0.02, height = 0.0001), size = 1.5, alpha = 1.0) + scale_y_continuous( name=&quot;Coverage&quot;, limits=c(0, 60), breaks=seq(0,60, 15), labels=c(&quot;0&quot;, &quot;15&quot;, &quot;30&quot;, &quot;45&quot;, &quot;60&quot;) ) + scale_x_discrete( name=&quot;Population Size&quot; )+ scale_shape_manual(values=SHAPE)+ scale_colour_manual(values = cb_palette, ) + scale_fill_manual(values = cb_palette) + ggtitle(&#39;Best satisfactory coverage&#39;)+ p_theme + coord_flip() + guides( shape=guide_legend(nrow=2, title.position = &quot;left&quot;, title = &#39;Population\\nSize&#39;), color=guide_legend(nrow=2, title.position = &quot;left&quot;, title = &#39;Population\\nSize&#39;), fill=guide_legend(nrow=2, title.position = &quot;left&quot;, title = &#39;Population\\nSize&#39;) ) 7.3.2.1 Summary statistics best %&gt;% group_by(pop_size) %&gt;% dplyr::summarise( count = n(), na_cnt = sum(is.na(coverage)), min = min(coverage, na.rm = TRUE), median = median(coverage, na.rm = TRUE), mean = mean(coverage, na.rm = TRUE), max = max(coverage, na.rm = TRUE), IQR = IQR(coverage, na.rm = TRUE) ) ## # A tibble: 5 × 8 ## pop_size count na_cnt min median mean max IQR ## &lt;fct&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 50 50 0 3 4 4.36 5 1 ## 2 100 50 0 7 9 8.62 10 1 ## 3 500 50 0 36 39.5 39.6 44 3 ## 4 1000 50 0 39 46.5 45.7 52 4.75 ## 5 5000 50 0 22 29 28.6 34 4.75 7.3.2.2 Kruskal-Wallis test kruskal.test(coverage ~ pop_size, data = best) ## ## Kruskal-Wallis rank sum test ## ## data: coverage by pop_size ## Kruskal-Wallis chi-squared = 237.63, df = 4, p-value &lt; 2.2e-16 7.3.2.3 Pairwise wilcoxon test best$pop_size &lt;- factor(best$pop_size, levels = c(1000,500,5000,100,50)) pairwise.wilcox.test(x = best$coverage, g = best$pop_size, p.adjust.method = &quot;bonferroni&quot;, paired = FALSE, conf.int = FALSE, alternative = &#39;l&#39;) ## ## Pairwise comparisons using Wilcoxon rank sum test with continuity correction ## ## data: best$coverage and best$pop_size ## ## 1000 500 5000 100 ## 500 5.7e-14 - - - ## 5000 &lt; 2e-16 &lt; 2e-16 - - ## 100 &lt; 2e-16 &lt; 2e-16 &lt; 2e-16 - ## 50 &lt; 2e-16 &lt; 2e-16 &lt; 2e-16 &lt; 2e-16 ## ## P value adjustment method: bonferroni "],["references.html", "References", " References "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
